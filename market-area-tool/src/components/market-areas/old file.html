<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Area Definition Tool</title>
    <!-- ArcGIS CSS -->
    <link rel="stylesheet" href="https://js.arcgis.com/4.24/esri/themes/light/main.css">
    <!-- External Libraries -->
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <!-- ArcGIS REST JS Modules -->
    <script src="https://unpkg.com/@esri/arcgis-rest-request@4.0.0/dist/umd/request.umd.min.js"></script>
    <script src="https://unpkg.com/@esri/arcgis-rest-feature-service@4.0.0/dist/umd/feature-service.umd.min.js"></script>
    <script src="https://unpkg.com/@esri/arcgis-rest-geoenrichment@4.0.0/dist/umd/geoenrichment.umd.min.js"></script>
    <script src="https://unpkg.com/@esri/arcgis-rest-auth@4.0.0/dist/umd/auth.umd.min.js"></script>
    <script src="https://unpkg.com/@esri/arcgis-to-geojson-utils@1.5.0/dist/arcgis-to-geojson-utils.umd.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        .drive-time-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 10px;
        }

        .drive-time-input {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .pin-icon {
            display: inline-block;
            margin-right: 4px;
        }

        #placePinButton.active {
            background-color: #4CAF50;
            color: white;
        }

        .drive-time-item {
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .coordinates {
            font-size: 0.875rem;
            color: #666;
        }
        /* Add these styles to your existing CSS */
        .location-item {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            background-color: #f8f9fa;
            transition: background-color 0.2s;
        }

        .location-item:hover {
            background-color: #e9ecef;
        }

        .location-item label {
            margin: 0;
            cursor: pointer;
        }

        .location-checkbox {
            margin-right: 8px;
        }

        /* Improve scrollbar appearance */
        #availableLocations, #selectedLocations {
            scrollbar-width: thin;
            scrollbar-color: #ccc #f0f0f0;
        }

        #availableLocations::-webkit-scrollbar, 
        #selectedLocations::-webkit-scrollbar {
            width: 8px;
        }

        #availableLocations::-webkit-scrollbar-track,
        #selectedLocations::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 4px;
        }

        #availableLocations::-webkit-scrollbar-thumb,
        #selectedLocations::-webkit-scrollbar-thumb {
            background-color: #ccc;
            border-radius: 4px;
        }
        .color-picker-popup {
            display: none;
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100%;
            background-color: white;
            box-shadow: -2px 0 5px rgba(0,0,0,0.2);
            z-index: 1000;
            overflow-y: auto;
        }

        .color-picker-content {
            padding: 20px;
        }

        .more-colors-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1001;
        }

        .more-colors-content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .color-section {
            margin-bottom: 15px;
        }

        .color-section h5 {
            margin-bottom: 5px;
            font-weight: bold;
        }

        .color-options {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            cursor: pointer;
        }

        .more-colors-button {
            width: 100%;
            padding: 10px;
            background-color: #f0f0f0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }

        .color-picker-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }

        .more-colors-content input[type="color"] {
            width: 100%;
            height: 50px;
            margin-bottom: 10px;
        }

        .color-inputs {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .color-inputs label {
            display: flex;
            align-items: center;
        }

        .color-inputs input {
            width: 100px;
            margin-left: 5px;
        }

        /* Additional styles for better usability */
        .color-picker-popup h4 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .recent-colors-section {
            margin-bottom: 20px;
        }

        .color-option:hover {
            transform: scale(1.1);
            transition: transform 0.2s ease;
        }

        .color-picker-close {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            cursor: pointer;
            background: none;
            border: none;
            color: #333;
        }

        .color-picker-close:hover {
            color: #000;
        }
        
        /* Reset and Base Styles */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
    
        html, body {
            height: 100%;
            width: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }
    
        /* Container */
        #mad-defs-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
    
        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 40px;
            background-color: #4CAF50;
            color: white;
            flex-shrink: 0;
        }
    
        .project-title {
            font-size: 28px;
            font-weight: 600;
        }
    
        .header-buttons .button {
            margin-left: 15px;
        }
    
        /* Tabs */
        .tab-container {
            display: flex;
            border-bottom: 1px solid #ccc;
            padding: 0 40px;
            background-color: #f9f9f9;
            flex-shrink: 0;
        }
    
        .map-tab {
            padding: 12px 20px;
            margin-right: 10px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            border-radius: 6px 6px 0 0;
            background-color: #e0e0e0;
            transition: background-color 0.3s ease, color 0.3s ease;
            font-weight: 500;
        }
    
        .active-map-tab {
            background-color: #ffffff;
            border-bottom: 2px solid #4CAF50;
            color: #4CAF50;
        }
    
        .add-new-tab {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
        }
    
        .add-new-tab:hover {
            background-color: #45a049;
        }
    
        /* Content Area */
        .content {
            display: flex;
            flex: 1;
            padding: 20px 40px;
            gap: 20px;
            overflow: hidden;
        }
    
        /* Left Column */
        .left-column {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
    
        .button-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
        }
    
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
    
        .button {
            padding: 10px 20px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s ease;
            font-weight: 500;
        }
    
        .button:hover {
            background-color: #e0e0e0;
        }
    
        .green-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
        }
    
        .green-button:hover {
            background-color: #45a049;
        }
    
        /* Search */
        .search-container {
            position: relative;
            flex-grow: 1;
            max-width: 300px;
            margin: 10px 0;
        }
    
        #searchInput {
            width: 100%;
            padding: 10px 35px 10px 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
    
        .clear-search {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            font-size: 20px;
            color: #999;
            display: none;
        }
    
        #searchResults {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: white;
            border: 1px solid #ccc;
            max-height: 200px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
            border-top: none;
        }
    
        #searchResults div {
            padding: 10px;
            cursor: pointer;
            font-size: 14px;
        }
    
        #searchResults div:hover {
            background-color: #f0f0f0;
        }
    
        /* Map Div */
        #mapDiv {
            flex: 1;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
    
        /* Right Column */
        .right-column {
            flex: 1.2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
    
        .ma-list {
            flex: 1;
            background-color: #ffffff;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 15px;
            overflow-y: auto;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
    
        .ma-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            cursor: move;
        }
    
        .ma-item:last-child {
            border-bottom: none;
        }
    
        .ma-item:hover {
            background-color: #f9f9f9;
        }
    
        .menu-button {
            background-color: transparent;
            border: none;
            cursor: pointer;
            font-size: 20px;
            color: #666;
            transition: color 0.3s ease;
        }
    
        .menu-button:hover {
            color: #333;
        }
    
        /* Market Area Form */
        #ma-form {
            display: none;
            flex-direction: column;
            background-color: #ffffff;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow-y: auto;
            max-height: 80vh;
        }
    
        #ma-form h3 {
            margin-bottom: 15px;
            font-size: 20px;
            color: #4CAF50;
            text-align: center;
        }
    
        .form-group {
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
        }
    
        .form-group label {
            font-weight: 600;
            margin-bottom: 3px;
            font-size: 12px;
        }
    
        .form-control {
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
            transition: border-color 0.3s ease;
        }
    
        .form-control:focus {
            border-color: #4CAF50;
        }
    
        /* Condensed layout for form sections */
        .form-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
    
        .form-row .form-group {
            flex: 1;
        }
    
        /* Zip Codes and Counties Entries */
        .entries-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
    
        .entries-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
    
        .entries-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    
        .entries-container {
            max-height: 100px;
            overflow-y: auto;
            padding-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            background-color: #f9f9f9;
        }
    
        .zip-code-entry, .county-entry {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            gap: 5px;
        }
    
        .zip-code-entry input[type="text"], .county-entry input[type="text"] {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
            transition: border-color 0.3s ease;
        }
    
        .zip-code-entry input[type="text"]:focus, .county-entry input[type="text"]:focus {
            border-color: #4CAF50;
        }
    
        /* County Suggestions */
        .county-suggestions {
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            width: calc(100% - 22px);
            max-height: 150px;
            overflow-y: auto;
            display: none;
            z-index: 1000;
        }
    
        /* Checkboxes */
        .acs-checkbox {
            appearance: none;
            -webkit-appearance: none;
            background-color: #fff;
            border: 1px solid #ccc;
            width: 16px;
            height: 16px;
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            vertical-align: middle;
            transition: border-color 0.3s ease, background-color 0.3s ease;
        }
    
        .acs-checkbox:checked::after {
            content: '';
            position: absolute;
            left: 5px;
            top: 2px;
            width: 4px;
            height: 8px;
            border: solid #4CAF50;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
    
        .acs-label {
            font-size: 12px;
            margin-left: 5px;
            color: #333;
        }
    
        /* Remove Entry Button */
        .remove-entry-button {
            background: none;
            border: none;
            color: #ff0000;
            font-size: 16px;
            cursor: pointer;
            transition: color 0.3s ease;
        }
    
        .remove-entry-button:hover {
            color: #cc0000;
        }
    
        /* Add Buttons */
        #addZipCode, #addCounty {
            padding: 6px 10px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s ease;
            align-self: flex-start;
        }
    
        #addZipCode:hover, #addCounty:hover {
            background-color: #45a049;
        }
        .ma-item.dragging {
            opacity: 0.5;
            background: #f0f0f0;
        }
        /* Save and Cancel Buttons */
        .button-row .button {
            padding: 8px 15px;
            font-size: 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            font-weight: 500;
        }
    
        .button-row .button:first-child {
            background-color: #f0f0f0;
            color: #333;
        }
    
        .button-row .button:first-child:hover {
            background-color: #e0e0e0;
        }
    
        .button-row .green-button {
            background-color: #4CAF50;
            color: white;
        }
    
        .button-row .green-button:hover {
            background-color: #45a049;
        }
    
        .remove-ma-button {
            background-color: #ff4d4d;
            color: white;
            margin-right: 10px;
        }
    
        .remove-ma-button:hover {
            background-color: #e60000;
        }
    
        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 8px;
        }
    
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
    
        ::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 4px;
        }
    
        ::-webkit-scrollbar-thumb:hover {
            background: #999;
        }
    
        /* Responsive Form Layout */
        @media (min-width: 768px) {
            .entries-section {
                flex-direction: row;
                gap: 20px;
            }
    
            .entries-group {
                flex: 1;
                display: flex;
                flex-direction: column;
            }
    
            .entries-group .entries-header {
                justify-content: space-between;
            }
        }
    
        /* Adjustments for smaller inputs */
        #transparency, #transparencyValue, #borderWeight {
            width: 60px;
        }
    
        /* Media queries for responsiveness */
        @media (max-width: 1200px) {
            .content {
                flex-direction: column;
            }
    
            .left-column, .right-column {
                flex: none;
                width: 100%;
            }
        }
    
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
                padding: 15px;
            }
    
            .header-buttons {
                margin-top: 10px;
            }
    
            .tab-container {
                padding: 0 15px;
            }
    
            .content {
                padding: 15px;
            }
    
            .button-row {
                flex-direction: column;
                align-items: stretch;
            }
    
            .search-container {
                max-width: none;
                margin: 10px 0;
            }
    
            .button-group {
                flex-direction: column;
            }
    
            .button {
                width: 100%;
                margin-bottom: 5px;
            }
            /* Styles for color input and display */
        }
        .color-input-container {
            display: flex;
            align-items: center;
        }

        .color-input {
            width: 60px;
            padding: 0;
            border: none;
            height: 30px;
        }

        .color-display {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    
    <input type="file" id="importExcelInput" accept=".xls,.xlsx,.xlsm" style="display: none;" />

    <div id="mad-defs-container">
        <!-- Header -->
        <div class="header">
            <span class="project-title" id="project-title">
                <span class="project-number">{{ project.project_number }}</span>
                <span class="project-separator"> - </span>
                <span class="project-client">{{ project.client }}</span>
                <span class="project-separator"> - </span>
                <span class="project-location">{{ project.location }}</span>
            </span>
            <div class="header-buttons">
                <button class="button" onclick="exportDefs()">Export Defs</button>
                <button class="button green-button" onclick="saveAndExit()">Save & Exit Project</button>
            </div>
        </div>
        
        <!-- Tabs -->
        <div class="tab-container" id="map-tabs">
            <!-- Example Tab (can be dynamically added) -->
            <!-- <div class="map-tab active-map-tab">MA Defs</div> -->
        </div>

        <!-- Content Area -->
        <div class="content">
            <!-- Left Column -->
            <div class="left-column">
                <!-- Button Row -->
                <div class="button-row">
                    <div class="button-group">
                        <button class="export-button button" onclick="exportData()">Export Data</button>
                        <button class="button" onclick="exportJPEG()">Export JPEG</button>
                        <button class="button" onclick="exportMxd()">Export MXD</button>
                    </div>
                    <div class="search-container">
                        <input type="text" id="searchInput" placeholder="Search for zip, state, city, or county">
                        <span id="clearSearch" class="clear-search">&times;</span>
                        <div id="searchResults"></div>
                    </div>                    
                    <div class="button-group">
                        <button class="button" onclick="bulkImportMAs()">Import MA Json</button>
                        <button class="button" id="importExcelButton">Import MA Excel</button>
                        <button class="button green-button" onclick="showCreateNewMAForm()">Create New MA</button>
                    </div>
                </div>
                <!-- Map Div -->
                <div id="mapDiv"></div>
            </div>

            <!-- Right Column -->
            <div class="right-column">
                <!-- Market Areas List -->
                <div id="ma-list" class="ma-list">
                    <!-- Dynamically populated Market Areas -->
                </div>
                <!-- Market Area Form -->
                <div id="ma-form">
                    <h3>Create Market Area</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="maType">MA Type</label>
                            <select id="maType" class="form-control" onchange="toggleMATypeFields()">
                                <option value="">Select type...</option>
                                <option value="zip">Zip Code</option>
                                <option value="county">County</option>
                                <option value="place">Place</option>
                                <option value="tract">Census Tract</option>
                                <option value="block">Census Block</option>
                                <option value="blockgroup">Census Block Group</option>
                                <option value="drivetime">Drive Time</option>
                                <option value="radius">Radius</option>
                                <option value="cbsa">CBSA</option>
                                <option value="state">State</option>
                                <option value="usa">USA</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="maName">MA Name</label>
                            <input type="text" id="maName" class="form-control" placeholder="Enter Market Area Name">
                        </div>
                        <div class="form-group">
                            <label for="shortName">Short Name (Optional)</label>
                            <input type="text" id="shortName" class="form-control" placeholder="Enter Short Name">
                        </div>
                    </div>

                    <div class="entries-section" style="width: 100%; display: flex; flex-direction: column; gap: 20px;">
                        <!-- Full-width Search Row -->
                        <div style="width: 100%;">
                            <input type="text" 
                                   id="locationSearch" 
                                   class="form-control" 
                                   placeholder="Search for locations..." 
                                   style="width: 100%; 
                                          padding: 12px;
                                          border: 1px solid #ccc; 
                                          border-radius: 4px;
                                          font-size: 14px;
                                          margin-bottom: 15px;">
                        </div>
                        
                        <!-- Tables Section -->
                        <div style="display: flex; width: 100%; gap: 20px;">
                            <!-- Available Locations Column -->
                            <div style="flex: 1;">
                                <!-- Header Row -->
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <label style="font-weight: 500;">Available Locations</label>
                                    <label style="display: flex; align-items: center;">
                                        <input type="checkbox" id="selectAllAvailableLocations" class="acs-checkbox">
                                        <span class="acs-label" style="margin-left: 4px;">Select All</span>
                                    </label>
                                </div>
                                <div id="availableLocations" 
                                     style="border: 1px solid #eee; 
                                            border-radius: 4px; 
                                            height: 300px; 
                                            overflow-y: auto; 
                                            padding: 10px;
                                            background-color: white;">
                                </div>
                            </div>
                    
                            <!-- Transfer Buttons -->
                            <div style="display: flex; flex-direction: column; justify-content: center; gap: 10px;">
                                <button onclick="moveSelectedLocations('right')" 
                                        class="button" 
                                        style="padding: 8px 12px; min-width: 40px;">→</button>
                                <button onclick="moveSelectedLocations('left')" 
                                        class="button" 
                                        style="padding: 8px 12px; min-width: 40px;">←</button>
                            </div>
                    
                            <!-- Selected Locations Column -->
                            <div style="flex: 1;">
                                <!-- Header Row -->
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                </div>
                                <div id="selectedLocations" 
                                     style="border: 1px solid #eee; 
                                            border-radius: 4px; 
                                            height: 300px; 
                                            overflow-y: auto; 
                                            padding: 10px;
                                            background-color: white;">
                                </div>

                                <div id="driveTimeSection" style="display: none;" class="entries-section">
                                    <div class="form-group">
                                        <div class="drive-time-controls">
                                            <button id="placePinButton" class="button">
                                                <span class="pin-icon">📍</span> Place Pin
                                            </button>
                                            <div class="drive-time-input">
                                                <label for="driveTimeMinutes">Drive Time (minutes):</label>
                                                <input type="number" 
                                                       id="driveTimeMinutes" 
                                                       class="form-control" 
                                                       min="1" 
                                                       max="120" 
                                                       value="10" 
                                                       disabled>
                                            </div>
                                        </div>
                                        <p id="pinInstructions" class="text-sm" style="display: none;">
                                            Click on the map to set the drive time center point
                                        </p>
                                    </div>
                                    <!-- Display selected drive time location -->
                                    <div id="selectedDriveTime" class="entries-container" style="margin-top: 10px;">
                                    </div>
                                </div>

                                <div id="radiusSection" style="display: none;" class="entries-section">
                                    <div class="form-group">
                                        <div class="radius-controls">
                                            <button id="radiusPinButton" class="button">
                                                <span class="pin-icon">📍</span> Place Pin
                                            </button>
                                            <div id="radiusList" style="margin-top: 10px;">
                                                <div class="radius-entry" style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                                    <input type="number" class="radius-input form-control" min="0.1" step="0.1" value="1" style="width: 80px;">
                                                    <span>miles</span>
                                                    <button class="remove-radius-button button" onclick="removeRadius(this)">Remove</button>
                                                </div>
                                            </div>
                                            <button id="addRadiusButton" class="button" style="margin-top: 10px;">
                                                Add Radius
                                            </button>
                                        </div>
                                        <p id="radiusPinInstructions" class="text-sm" style="display: none; margin-top: 8px;">
                                            Click on the map to set the radius center point
                                        </p>
                                    </div>
                                    <div id="selectedRadius" class="entries-container" style="margin-top: 10px;"></div>
                                </div>

                            </div>
                        </div>
                    </div>
                <!-- Replace the existing color selection part in the MA form with this -->
                <div class="form-row">
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="acsCheckbox" class="acs-checkbox" checked> 
                            <span class="acs-label">ACS</span>
                        </label>
                    </div>
                    <div class="form-group">
                        <label for="fillColor">Fill Color</label>
                        <div class="color-input-container">
                            <div id="fillColorDisplay" class="color-display" onclick="showColorPicker('fill')"></div>
                            <input type="hidden" id="fillColor" name="fillColor">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="transparency">Transparency</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input type="range" id="transparency" class="form-control" min="0" max="100" value="50" style="width: 100px;">
                            <input type="number" id="transparencyValue" min="0" max="100" value="50" class="form-control" style="width: 50px;">
                            <span>%</span>
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label for="borderColor">Border Color</label>
                        <div class="color-input-container">
                            <div id="borderColorDisplay" class="color-display" onclick="showColorPicker('border')"></div>
                            <input type="hidden" id="borderColor" name="borderColor">
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="borderWeight">Border Weight</label>
                        <input type="number" id="borderWeight" class="form-control" min="0" max="10" value="1">
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="noBorder" onchange="toggleBorderWeight()" class="acs-checkbox"> 
                            <span class="acs-label">No Border</span>
                        </label>
                    </div>
                </div>

                <!-- Button Row -->
                <div class="button-row">
                    <button class="button" onclick="cancelCreateMA()">Cancel</button>
                    <button class="button green-button" onclick="saveAndExitMA()">Save & Exit</button>
                </div>

                <div id="colorPickerPopup" class="color-picker-popup">
                    <div class="color-picker-content">
                        <h4>Select Color</h4>
                        <div id="colorPaletteContainer"></div>
                        <div class="recent-colors-section">
                            <h5>Recent Colors</h5>
                            <div id="recentColors" class="color-options"></div>
                        </div>
                        <div class="more-colors-section">
                            <button onclick="showMoreColorsDialog()" class="more-colors-button">More Colors...</button>
                        </div>
                        <div class="color-picker-actions">
                            <button onclick="closeColorPicker()">Close</button>
                        </div>
                    </div>
                </div>
                
                <div id="moreColorsDialog" class="more-colors-dialog">
                    <div class="more-colors-content">
                        <h4>Custom Color</h4>
                        <input type="color" id="customColorPicker">
                        <div class="color-inputs">
                            <label>Hex: <input type="text" id="hexInput"></label>
                        </div>
                        <div class="color-picker-actions">
                            <button onclick="applyCustomColor()">Apply</button>
                            <button onclick="closeMoreColorsDialog()">Cancel</button>
                        </div>
                    </div>
                        <div id="radiusSection" style="display: none;" class="entries-section">
                            <div class="form-group">
                                <div class="radius-controls">
                                    <button id="radiusPinButton" class="button">
                                        <span class="pin-icon">📍</span> Place Pin
                                    </button>
                                    <div id="radiusList" style="margin-top: 10px;">
                                        <div class="radius-entry" style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                                            <input type="number" class="radius-input form-control" min="0.1" step="0.1" value="1" style="width: 80px;">
                                            <span>miles</span>
                                            <button class="remove-radius-button button" onclick="removeRadius(this)">Remove</button>
                                        </div>
                                    </div>
                                    <button id="addRadiusButton" class="button" style="margin-top: 10px;">
                                        Add Radius
                                    </button>
                                </div>
                                <p id="radiusPinInstructions" class="text-sm" style="display: none; margin-top: 8px;">
                                    Click on the map to set the radius center point
                                </p>
                            </div>
                            <div id="selectedRadius" class="entries-container" style="margin-top: 10px;"></div>
                        </div>
                    `;
                </div>
            </div>
        </div>
        <script>
            const ARCGIS_API_KEY = "{{ api_key }}";

            // Add status notification element to the page
            const statusHtml = `
            <div id="exportStatusIndicator" class="fixed bottom-4 right-4 hidden" style="
                position: fixed;
                bottom: 1rem;
                right: 1rem;
                background: white;
                padding: 1rem;
                border-radius: 0.5rem;
                box-shadow: 0 2px 8px rgba(0,0,0,0.15);
                z-index: 1000;
                display: none;
            ">
                <div class="flex items-center gap-3" style="display: flex; align-items: center; gap: 0.75rem;">
                    <div class="spinner" style="
                        width: 20px;
                        height: 20px;
                        border: 2px solid #4CAF50;
                        border-top-color: transparent;
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                    "></div>
                    <div>
                        <p class="font-medium" id="exportStatusText">Exporting data...</p>
                        <p class="text-sm text-gray-500" id="exportStatusSubtext">This may take a few minutes</p>
                    </div>
                </div>
            </div>

            <style>
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
            </style>`;
            // Then in initialization:
            // Global variables to store available and selected locations
            let availableLocations = [];
            let selectedLocations = [];
            let currentSearchTimeout = null;



            let isPinMode = false;
            let driveTimeMapClickHandler = null;


            // Global variables for radius functionality
            let isRadiusPinMode = false;
            let radiusMapClickHandler = null;

            function initializeRadius() {
                // Set up initial radius input
                const radiusList = document.getElementById('radiusList');
                if (!radiusList.children.length) {
                    const entry = document.createElement('div');
                    entry.className = 'radius-entry';
                    entry.style.cssText = 'display: flex; align-items: center; gap: 10px; margin-bottom: 8px;';
                    entry.innerHTML = `
                        <input type="number" class="radius-input form-control" min="0.1" step="0.1" value="1" style="width: 80px;">
                        <span>miles</span>
                        <button class="remove-radius-button button" onclick="removeRadius(this)">Remove</button>
                    `;
                    radiusList.appendChild(entry);
                }

                // Initialize pin button state
                const pinButton = document.getElementById('radiusPinButton');
                if (pinButton) {
                    pinButton.innerHTML = '<span class="pin-icon">📍</span> Place Pin';
                    pinButton.classList.remove('active');
                }

                // Reset selected radius display
                const selectedRadius = document.getElementById('selectedRadius');
                if (selectedRadius) {
                    selectedRadius.innerHTML = '';
                }

                // Clear any existing graphics
                if (layers.highlightLayer) {
                    layers.highlightLayer.removeAll();
                }

                // Reset map click handler
                if (radiusMapClickHandler) {
                    radiusMapClickHandler.remove();
                    radiusMapClickHandler = null;
                }
                isRadiusPinMode = false;

                // Clear selected locations
                selectedLocations = [];
            }



            function addNewRadius() {
                const radiusList = document.getElementById('radiusList');
                const newEntry = document.createElement('div');
                newEntry.className = 'radius-entry';
                newEntry.style.cssText = 'display: flex; align-items: center; gap: 10px; margin-bottom: 8px;';
                newEntry.innerHTML = `
                    <input type="number" class="radius-input form-control" min="0.1" step="0.1" value="1" style="width: 80px;">
                    <span>miles</span>
                    <button class="remove-radius-button button" onclick="removeRadius(this)">Remove</button>
                `;
                radiusList.appendChild(newEntry);
            }

            function removeRadius(button) {
                const entry = button.closest('.radius-entry');
                if (entry) {
                    entry.remove();
                    updateRadiusDisplay();
                }
            }

            async function handleRadiusMapClick(event) {
                const point = mapViewInstance.toMap({
                    x: event.x,
                    y: event.y
                });
                
                // Get all radius values
                const radiusInputs = document.querySelectorAll('.radius-input');
                const radiusValues = Array.from(radiusInputs).map(input => parseFloat(input.value));
                
                await generateRadiusAreas(point, radiusValues);
                updateSelectedRadius(point, radiusValues);
            }

            function updateSelectedRadius(point, radiusValues) {
                const selectedRadius = document.getElementById('selectedRadius');
                selectedRadius.innerHTML = `
                    <div class="radius-item">
                        <span>Center Point</span>
                        <span class="coordinates">
                            (${point.x.toFixed(4)}, ${point.y.toFixed(4)})
                        </span>
                        <div>Radius Values: ${radiusValues.join(', ')} miles</div>
                    </div>
                `;
            }

            async function generateRadiusAreas(point, radiusValues) {
                try {
                    require([
                        "esri/Graphic",
                        "esri/geometry/Circle",
                        "esri/geometry/Point"
                    ], function(Graphic, Circle, Point) {
                        // Clear existing graphics
                        if (layers.highlightLayer) {
                            layers.highlightLayer.removeAll();
                        }

                        // Create center point graphic
                        const centerPoint = new Point({
                            x: point.x,
                            y: point.y,
                            spatialReference: mapViewInstance.spatialReference
                        });

                        const pointGraphic = new Graphic({
                            geometry: centerPoint,
                            symbol: {
                                type: "simple-marker",
                                style: "circle",
                                color: [255, 0, 0],
                                size: 8
                            }
                        });

                        // Create circles for each radius
                        const circles = radiusValues.map(radius => {
                            const circleGeometry = new Circle({
                                center: centerPoint,
                                radius: radius,
                                radiusUnit: "miles",
                                spatialReference: mapViewInstance.spatialReference
                            });

                            return new Graphic({
                                geometry: circleGeometry,
                                symbol: {
                                    type: "simple-fill",
                                    color: hexToRGBA(
                                        document.getElementById('fillColor').value,
                                        (100 - document.getElementById('transparency').value) / 100
                                    ),
                                    outline: {
                                        color: document.getElementById('borderColor').value,
                                        width: document.getElementById('noBorder').checked ? 0 : 
                                            document.getElementById('borderWeight').value
                                    }
                                }
                            });
                        });

                        // Add all graphics to the layer
                        layers.highlightLayer.add(pointGraphic);
                        circles.forEach(circle => layers.highlightLayer.add(circle));

                        // Store for saving
                        selectedLocations = [{
                            id: `radius-${point.x}-${point.y}`,
                            name: `Radius Areas`,
                            type: 'radius',
                            centerPoint: centerPoint,
                            radiusValues: radiusValues,
                            geometries: circles.map(circle => circle.geometry)
                        }];

                        // Zoom to the largest circle
                        const largestCircle = circles[circles.length - 1];
                        if (largestCircle) {
                            mapViewInstance.goTo(largestCircle.geometry);
                        }
                    });
                } catch (error) {
                    console.error('Error generating radius areas:', error);
                    alert("Error generating radius areas. Please try again.");
                }
            }

            function updateRadiusDisplay(point, radiusValues) {
                const selectedRadius = document.getElementById('selectedRadius');
                if (!selectedRadius) return;

                selectedRadius.innerHTML = `
                    <div class="radius-item">
                        <span>Center Point</span>
                        <span class="coordinates">
                            (${point.x.toFixed(4)}, ${point.y.toFixed(4)})
                        </span>
                        <div>Radius Values: ${radiusValues.map(r => `${r} miles`).join(', ')}</div>
                    </div>
                `;
            }


            function initializeDriveTimeControls() {
                const pinButton = document.getElementById('placePinButton');
                const driveTimeInput = document.getElementById('driveTimeMinutes');
                const pinInstructions = document.getElementById('pinInstructions');
                
                // Reset state
                isPinMode = false;
                if (driveTimeMapClickHandler) {
                    driveTimeMapClickHandler.remove();
                    driveTimeMapClickHandler = null;
                }
                
                pinButton.onclick = togglePinMode;
                driveTimeInput.onchange = validateDriveTime;
                
                function togglePinMode() {
                    isPinMode = !isPinMode;
                    
                    // Update UI
                    pinButton.innerHTML = isPinMode ? 
                        '<span class="pin-icon">📍</span> Cancel Pin' : 
                        '<span class="pin-icon">📍</span> Place Pin';
                    pinButton.classList.toggle('active', isPinMode);
                    driveTimeInput.disabled = !isPinMode;
                    pinInstructions.style.display = isPinMode ? 'block' : 'none';
                    
                    // Handle map clicks
                    if (isPinMode) {
                        driveTimeMapClickHandler = mapViewInstance.on("click", handleDriveTimeMapClick);
                    } else if (driveTimeMapClickHandler) {
                        driveTimeMapClickHandler.remove();
                        driveTimeMapClickHandler = null;
                    }
                }
            }

            function validateDriveTime(event) {
                let value = parseInt(event.target.value) || 0;
                value = Math.min(Math.max(value, 1), 120); // Limit between 1-120 minutes
                event.target.value = value;
            }

            async function handleDriveTimeMapClick(event) {
                const point = mapViewInstance.toMap({
                    x: event.x,
                    y: event.y
                });
                
                const minutes = parseInt(document.getElementById('driveTimeMinutes').value);
                await generateDriveTimeArea(point, minutes);
                
                // Update selected drive time display
                updateSelectedDriveTime(point, minutes);
            }

            function updateSelectedDriveTime(point, minutes) {
                const selectedDriveTime = document.getElementById('selectedDriveTime');
                selectedDriveTime.innerHTML = `
                    <div class="drive-time-item">
                        <span>${minutes} Minute Drive Time</span>
                        <span class="coordinates">
                            (${point.x.toFixed(4)}, ${point.y.toFixed(4)})
                        </span>
                    </div>
                `;
            }

            async function generateDriveTimeArea(point, minutes) {
                try {
                    require([
                        "esri/Graphic",
                        "esri/geometry/Point",
                        "esri/rest/serviceArea",
                        "esri/rest/support/ServiceAreaParameters",
                        "esri/rest/support/FeatureSet",
                        "esri/config"
                    ], function(Graphic, Point, serviceArea, ServiceAreaParameters, FeatureSet, esriConfig) {
                        // Set the API key
                        esriConfig.apiKey = ARCGIS_API_KEY;

                        // Create point graphic
                        const pointGraphic = new Graphic({
                            geometry: point,
                            symbol: {
                                type: "simple-marker",
                                style: "circle",
                                color: [255, 0, 0],
                                size: 8
                            }
                        });

                        // Setup service area parameters
                        const serviceUrl = "https://route-api.arcgis.com/arcgis/rest/services/World/ServiceAreas/NAServer/ServiceArea_World";
                        
                        const features = {
                            features: [{
                                geometry: point
                            }],
                            spatialReference: point.spatialReference
                        };

                        const params = new ServiceAreaParameters({
                            facilities: new FeatureSet(features),
                            defaultBreaks: [minutes],
                            outSpatialReference: mapViewInstance.spatialReference,
                            returnPolygons: true,
                            travelMode: {
                                "attributeParameterValues": [],
                                "description": "Driving time for cars",
                                "impedanceAttributeName": "TravelTime",
                                "simplificationToleranceUnits": "meters",  // Changed from esriMeters
                                "type": "automobile",  // Changed from AUTOMOBILE
                                "useHierarchy": true,
                                "restrictUTurns": "esriNFSBAtDeadEndsAndIntersections",
                                "simplificationTolerance": 2,
                                "timeAttributeName": "TravelTime",
                                "distanceAttributeName": "Miles",
                                "name": "Driving Time"
                            }
                        });

                        // Get service area
                        serviceArea.solve(serviceUrl, params)
                            .then(function(response) {
                                if (response.serviceAreaPolygons.length > 0) {
                                    const polygon = response.serviceAreaPolygons[0].geometry;
                                    
                                    // Create polygon graphic
                                    const polygonGraphic = new Graphic({
                                        geometry: polygon,
                                        symbol: {
                                            type: "simple-fill",
                                            color: hexToRGBA(
                                                document.getElementById('fillColor').value,
                                                (100 - document.getElementById('transparency').value) / 100
                                            ),
                                            outline: {
                                                color: document.getElementById('borderColor').value,
                                                width: document.getElementById('noBorder').checked ? 0 : 
                                                    document.getElementById('borderWeight').value
                                            }
                                        }
                                    });

                                    // Update layers
                                    layers.highlightLayer.removeAll();
                                    layers.highlightLayer.addMany([polygonGraphic, pointGraphic]);
                                    
                                    // Store for saving
                                    selectedLocations = [{
                                        id: `drivetime-${point.x}-${point.y}`,
                                        name: `${minutes} Minute Drive Time`,
                                        type: 'drivetime',
                                        geometry: polygon,
                                        centerPoint: point,
                                        minutes: minutes
                                    }];
                                    
                                    // Zoom to the drive time area
                                    mapViewInstance.goTo(polygon);
                                }
                            })
                            .catch(function(error) {
                                console.error("Error solving service area:", error);
                                alert("Error generating drive time area. Please try again.");
                            });
                    });
                } catch (error) {
                    console.error('Error generating drive time area:', error);
                    alert("Error initializing drive time service. Please try again.");
                }
            }




            
            function initializeLocationSelector() {
                if (!document.getElementById('availableLocations')) {
                    const entriesSection = document.querySelector('.entries-section');
                    if (entriesSection) {
                        entriesSection.innerHTML = `
                            <!-- Tables Section with Search -->
                            <div style="width: 100%; display: flex; flex-direction: column; gap: 10px;">
                                <!-- Labels and Search Row -->
                                <div style="display: flex; width: 100%; gap: 20px;">
                                    <!-- Search over Available Locations -->
                                    <div style="flex: 1;">
                                        <input type="text" id="locationSearch" class="form-control" 
                                            placeholder="Search for locations..." 
                                            style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                                    </div>
                                    
                                    <!-- Spacer for Transfer Buttons -->
                                    <div style="width: 40px;"></div>
                                    
                                    <!-- Empty space to align with Selected Locations -->
                                    <div style="flex: 1;"></div>
                                </div>

                                <!-- Headers Row -->
                                <div style="display: flex; width: 100%; gap: 20px;">
                                    <!-- Available Header -->
                                    <div style="flex: 1; display: flex; justify-content: space-between; align-items: center;">
                                        <label style="font-weight: 500;">Available Locations</label>
                                        <label style="display: flex; align-items: center;">
                                            <input type="checkbox" id="selectAllAvailableLocations" class="acs-checkbox">
                                            <span class="acs-label" style="margin-left: 4px;">Select All</span>
                                        </label>
                                    </div>

                                    <!-- Spacer for Transfer Buttons -->
                                    <div style="width: 40px;"></div>

                                    <!-- Selected Header -->
                                    <div style="flex: 1; display: flex; justify-content: space-between; align-items: center;">
                                        <div style="display: flex; align-items: center;">
                                            <label style="font-weight: 500;">Selected Locations</label>
                                            <span id="selectedLocationsCount" style="margin-left: 8px; font-size: 0.875rem; color: #666;">
                                                (0 selected)
                                            </span>
                                        </div>
                                        <label style="display: flex; align-items: center;">
                                            <input type="checkbox" id="selectAllSelectedLocations" class="acs-checkbox">
                                            <span class="acs-label" style="margin-left: 4px;">Select All</span>
                                        </label>
                                    </div>
                                </div>

                                <!-- Tables and Buttons Row -->
                                <div style="display: flex; gap: 20px;">
                                    <!-- Available Locations Box -->
                                    <div style="flex: 1;">
                                        <div id="availableLocations" 
                                            style="border: 1px solid #eee; 
                                                border-radius: 4px; 
                                                height: 400px; 
                                                overflow-y: auto; 
                                                padding: 10px;
                                                background-color: white;">
                                        </div>
                                    </div>

                                    <!-- Transfer Buttons -->
                                    <div style="display: flex; flex-direction: column; justify-content: center; gap: 10px;">
                                        <button onclick="moveSelectedLocations('right')" 
                                                class="button" 
                                                style="padding: 8px 12px; min-width: 40px;">→</button>
                                        <button onclick="moveSelectedLocations('left')" 
                                                class="button" 
                                                style="padding: 8px 12px; min-width: 40px;">←</button>
                                    </div>

                                    <!-- Selected Locations Box -->
                                    <div style="flex: 1;">
                                        <div id="selectedLocations" 
                                            style="border: 1px solid #eee; 
                                                border-radius: 4px; 
                                                height: 400px; 
                                                overflow-y: auto; 
                                                padding: 10px;
                                                background-color: white;">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }

                // Update search placeholder based on type
                const searchInput = document.getElementById('locationSearch');
                if (searchInput) {
                    const maType = document.getElementById('maType').value;
                    searchInput.placeholder = maType === 'zip' ? 
                        "Search for zip codes..." : 
                        "Search for counties...";
                    searchInput.removeEventListener('input', handleLocationSearch);
                    searchInput.addEventListener('input', debounce(handleLocationSearch, 300));
                }

                // Initialize arrays if they don't exist
                availableLocations = availableLocations || [];
                selectedLocations = selectedLocations || [];

                // Set up select all handlers
                const selectAllAvailable = document.getElementById('selectAllAvailableLocations');
                const selectAllSelected = document.getElementById('selectAllSelectedLocations');

                if (selectAllAvailable) {
                    selectAllAvailable.addEventListener('change', () => {
                        const checkboxes = document.querySelectorAll('#availableLocations input[type="checkbox"]:not(:disabled)');
                        checkboxes.forEach(checkbox => checkbox.checked = selectAllAvailable.checked);
                    });
                }

                if (selectAllSelected) {
                    selectAllSelected.addEventListener('change', () => {
                        const checkboxes = document.querySelectorAll('#selectedLocations input[type="checkbox"]:not(:disabled)');
                        checkboxes.forEach(checkbox => checkbox.checked = selectAllSelected.checked);
                    });
                }

                updateLocationLists();
            }

            // Updated searchCensusTracts function using TIGERweb API
            async function searchCensusTracts(query) {
                console.log('Starting census tract search with query:', query);
                
                // TIGERweb Census 2020 API endpoint for Census Tracts
                const baseUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Census2020/MapServer/6/query";
                
                // Build where clause based on query type
                let whereClause;
                if (query.match(/^\d+$/)) {
                    // If query is numeric, search by TRACT number
                    whereClause = `TRACT LIKE '${query}%'`;
                } else {
                    // If text, search by name or basename
                    const safeQuery = query.replace(/'/g, "''").replace(/[&<>"']/g, '');
                    whereClause = `BASENAME LIKE '%${safeQuery}%' OR NAME LIKE '%${safeQuery}%'`;
                }

                // Build query parameters
                const params = {
                    where: whereClause,
                    outFields: 'GEOID,TRACT,NAME,BASENAME,STATE,COUNTY,AREALAND,AREAWATER,POP100,HU100',
                    f: 'json',
                    returnGeometry: 'false',
                    returnDistinctValues: 'true'
                };

                const searchParams = new URLSearchParams();
                Object.entries(params).forEach(([key, value]) => {
                    searchParams.append(key, value);
                });

                const url = `${baseUrl}?${searchParams.toString()}`;
                console.log('TIGER API Request URL:', url);

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('TIGER API Census tract search response:', data);

                    if (data.error) {
                        console.error('TIGER API Service error:', data.error);
                        availableLocations = [];
                    } else if (data.features && data.features.length > 0) {
                        console.log('Number of tracts found:', data.features.length);
                        
                        availableLocations = data.features
                            .map(feature => {
                                const attrs = feature.attributes;
                                // Format name with additional info (population, housing units)
                                const popInfo = attrs.POP100 ? ` (Pop: ${attrs.POP100.toLocaleString()})` : '';
                                const huInfo = attrs.HU100 ? ` (Housing: ${attrs.HU100.toLocaleString()})` : '';
                                
                                return {
                                    id: attrs.GEOID,
                                    name: `Census Tract ${attrs.TRACT}, ${attrs.NAME || attrs.BASENAME}${popInfo}${huInfo}`,
                                    type: 'tract',
                                    tractId: attrs.TRACT,
                                    stateId: attrs.STATE,
                                    countyId: attrs.COUNTY,
                                    geoid: attrs.GEOID,
                                    population: attrs.POP100,
                                    housingUnits: attrs.HU100
                                };
                            })
                            .filter(tract => !selectedLocations.some(selected => selected.id === tract.id));

                        console.log('Processed tract locations:', availableLocations);
                    } else {
                        console.log('No census tracts found');
                        availableLocations = [];
                    }
                } catch (error) {
                    console.error('Error in TIGER API census tract search:', error);
                    availableLocations = [];
                }

                updateLocationLists();
            }
            
            function clearHighlightGraphics() {
                if (layers.highlightLayer) {
                    layers.highlightLayer.removeAll();
                }
            }

            // Search functions for new types
            async function searchCensusBlocks(query) {
                console.log('Starting Census Block search with query:', query);
                
                const baseUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Tracts_Blocks/MapServer/12/query";
                
                try {
                    // Build where clause based on query type
                    let whereClause;
                    if (query.match(/^\d+$/)) {
                        // If query is numeric, search by block number
                        whereClause = `BLOCK LIKE '${query}%'`;
                    } else {
                        // If text, search by county or state name component
                        const safeQuery = query.replace(/'/g, "''").replace(/[&<>"']/g, '');
                        whereClause = `COUNTY LIKE '%${safeQuery}%' OR STATE LIKE '%${safeQuery}%'`;
                    }

                    const params = new URLSearchParams({
                        f: 'json',
                        where: whereClause,
                        outFields: 'GEOID,BLOCK,STATE,COUNTY,TRACT,BLKID,POP100',
                        returnGeometry: 'false',
                        returnDistinctValues: 'true',
                        orderByFields: 'STATE,COUNTY,TRACT,BLOCK'
                    });

                    const url = `${baseUrl}?${params.toString()}`;
                    console.log('Census Blocks API Request URL:', url);

                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('Census Blocks API search response:', data);

                    if (data.features && data.features.length > 0) {
                        console.log('Number of blocks found:', data.features.length);
                        
                        availableLocations = data.features
                            .map(feature => {
                                const attrs = feature.attributes;
                                const popInfo = attrs.POP100 ? ` (Pop: ${attrs.POP100.toLocaleString()})` : '';
                                
                                return {
                                    id: attrs.GEOID,
                                    name: `Block ${attrs.BLOCK}, Tract ${attrs.TRACT}, ${attrs.COUNTY} County, ${attrs.STATE}${popInfo}`,
                                    type: 'block',
                                    blockId: attrs.BLOCK,
                                    tractId: attrs.TRACT,
                                    countyId: attrs.COUNTY,
                                    stateId: attrs.STATE,
                                    geoid: attrs.GEOID,
                                    population: attrs.POP100
                                };
                            })
                            .filter(block => !selectedLocations.some(selected => selected.id === block.id));
                    } else {
                        availableLocations = [];
                    }
                    
                    updateLocationLists();
                } catch (error) {
                    console.error('Error searching Census Blocks:', error);
                    availableLocations = [];
                    updateLocationLists();
                }
            }

            async function searchBlockGroups(query) {
                console.log('Starting Block Group search with query:', query);
                
                const baseUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Tracts_Blocks/MapServer/1/query";
                
                try {
                    // Build where clause based on query type
                    let whereClause;
                    if (query.match(/^\d+$/)) {
                        // If query is numeric, search by block group number
                        whereClause = `BLKGRP LIKE '${query}%'`;
                    } else {
                        // If text, search by county or state name component
                        const safeQuery = query.replace(/'/g, "''").replace(/[&<>"']/g, '');
                        whereClause = `COUNTY LIKE '%${safeQuery}%' OR STATE LIKE '%${safeQuery}%'`;
                    }

                    const params = new URLSearchParams({
                        f: 'json',
                        where: whereClause,
                        outFields: 'GEOID,BLKGRP,STATE,COUNTY,TRACT,BLKGRPID,POP100',
                        returnGeometry: 'false',
                        returnDistinctValues: 'true',
                        orderByFields: 'STATE,COUNTY,TRACT,BLKGRP'
                    });

                    const url = `${baseUrl}?${params.toString()}`;
                    console.log('Block Groups API Request URL:', url);

                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('Block Groups API search response:', data);

                    if (data.features && data.features.length > 0) {
                        console.log('Number of block groups found:', data.features.length);
                        
                        availableLocations = data.features
                            .map(feature => {
                                const attrs = feature.attributes;
                                const popInfo = attrs.POP100 ? ` (Pop: ${attrs.POP100.toLocaleString()})` : '';
                                
                                return {
                                    id: attrs.GEOID,
                                    name: `Block Group ${attrs.BLKGRP}, Tract ${attrs.TRACT}, ${attrs.COUNTY} County, ${attrs.STATE}${popInfo}`,
                                    type: 'blockgroup',
                                    blockGroupId: attrs.BLKGRP,
                                    tractId: attrs.TRACT,
                                    countyId: attrs.COUNTY,
                                    stateId: attrs.STATE,
                                    geoid: attrs.GEOID,
                                    population: attrs.POP100
                                };
                            })
                            .filter(bg => !selectedLocations.some(selected => selected.id === bg.id));
                    } else {
                        availableLocations = [];
                    }
                    
                    updateLocationLists();
                } catch (error) {
                    console.error('Error searching Block Groups:', error);
                    availableLocations = [];
                    updateLocationLists();
                }
            }

            async function queryFeatures(extent, maType) {
                if (isEditingOrCreating && !extent) {
                    console.log('In edit mode without extent, skipping feature query');
                    return [];
                }

                console.log('Starting queryFeatures with type:', maType);
                
                if (layers.highlightLayer) {
                    layers.highlightLayer.removeAll();
                }

                return new Promise((resolve, reject) => {
                    require([
                        "esri/geometry/Extent",
                        "esri/geometry/Polygon",
                        "esri/rest/support/Query",
                        "esri/rest/query",
                        "esri/geometry/SpatialReference",
                        "esri/geometry/support/webMercatorUtils"
                    ], function(Extent, Polygon, Query, query, SpatialReference, webMercatorUtils) {
                        let baseUrl;
                        let queryParams;

                        // Handle special cases first
                        if (maType === 'blockgroup') {
                            baseUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Tracts_Blocks/MapServer/1/query";
                            
                            const params = new URLSearchParams({
                                f: 'json',
                                where: isEditingOrCreating ? '1=1' : 
                                    `GEOID IN ('${marketAreas.find(ma => ma.type === 'blockgroup')?.areas.map(a => a.geoid).join("','")}')`,
                                geometry: JSON.stringify({
                                    xmin: extent.xmin,
                                    ymin: extent.ymin,
                                    xmax: extent.xmax,
                                    ymax: extent.ymax,
                                    spatialReference: { wkid: 102100 }
                                }),
                                geometryType: 'esriGeometryEnvelope',
                                inSR: '102100',
                                outSR: '102100',
                                outFields: '*',
                                returnGeometry: 'true',
                                spatialRel: 'esriSpatialRelIntersects'
                            });

                            console.log('Block Group query URL:', `${baseUrl}?${params.toString()}`);

                            fetch(`${baseUrl}?${params.toString()}`)
                                .then(response => response.json())
                                .then(data => {
                                    console.log('Block Groups query response:', data);
                                    
                                    if (data.error) {
                                        console.error('TIGERweb error:', data.error);
                                        resolve([]);
                                        return;
                                    }

                                    if (data.features && Array.isArray(data.features) && data.features.length > 0) {
                                        console.log(`Found ${data.features.length} block groups`);
                                        
                                        const convertedFeatures = data.features.map(feature => {
                                            if (!feature.geometry || !feature.geometry.rings) {
                                                console.warn('Block Group feature missing geometry or rings:', feature);
                                                return null;
                                            }

                                            const polygon = new Polygon({
                                                rings: feature.geometry.rings,
                                                spatialReference: { wkid: 102100 }
                                            });

                                            return {
                                                attributes: {
                                                    GEOID: feature.attributes.GEOID,
                                                    BLKGRPID: feature.attributes.BLKGRPID,
                                                    STATE: feature.attributes.STATE,
                                                    COUNTY: feature.attributes.COUNTY,
                                                    TRACT: feature.attributes.TRACT,
                                                    BLKGRP: feature.attributes.BLKGRP,
                                                    type: 'blockgroup'
                                                },
                                                geometry: polygon
                                            };
                                        }).filter(Boolean);

                                        console.log('Converted block group features:', convertedFeatures);
                                        resolve(convertedFeatures);
                                    } else {
                                        console.log('No block group features found');
                                        resolve([]);
                                    }
                                })
                                .catch(error => {
                                    console.error('Error querying block groups:', error);
                                    resolve([]);
                                });
                            return;
                        }

                        if (maType === 'block') {
                            const baseUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Tracts_Blocks/MapServer/12";
                            
                            const params = new URLSearchParams({
                                f: 'json',
                                where: isEditingOrCreating ? '1=1' : 
                                    `GEOID IN ('${marketAreas.find(ma => ma.type === 'block')?.areas.map(a => a.geoid).join("','")}')`,
                                geometry: JSON.stringify({
                                    xmin: extent.xmin,
                                    ymin: extent.ymin,
                                    xmax: extent.xmax,
                                    ymax: extent.ymax,
                                    spatialReference: { wkid: 102100 }
                                }),
                                geometryType: 'esriGeometryEnvelope',
                                inSR: '102100',
                                outSR: '102100',
                                outFields: '*',
                                returnGeometry: true,
                                spatialRel: 'esriSpatialRelIntersects'
                            });

                            const queryUrl = `${baseUrl}/query?${params.toString()}`;
                            console.log('[queryFeatures] Census Block query URL:', queryUrl);

                            fetch(queryUrl)
                                .then(response => response.json())
                                .then(data => {
                                    console.log('[queryFeatures] Census Block response:', data);
                                    
                                    if (data.error) {
                                        console.error('[queryFeatures] TIGERweb error:', data.error);
                                        resolve([]);
                                        return;
                                    }

                                    if (data.features && Array.isArray(data.features)) {
                                        console.log(`[queryFeatures] Processing ${data.features.length} census blocks`);
                                        
                                        const convertedFeatures = data.features.map((feature, index) => {
                                            console.log(`[queryFeatures] Processing block ${index + 1}:`, {
                                                GEOID: feature.attributes.GEOID,
                                                BLOCK: feature.attributes.BLOCK,
                                                TRACT: feature.attributes.TRACT
                                            });

                                            if (!feature.geometry || !feature.geometry.rings) {
                                                console.warn('[queryFeatures] Block missing geometry:', feature);
                                                return null;
                                            }

                                            const polygon = new Polygon({
                                                rings: feature.geometry.rings,
                                                spatialReference: { wkid: 102100 }
                                            });

                                            return {
                                                geometry: polygon,
                                                attributes: {
                                                    id: feature.attributes.GEOID,
                                                    name: `Block ${feature.attributes.BLOCK}, Tract ${feature.attributes.TRACT}`,
                                                    type: 'block',
                                                    GEOID: feature.attributes.GEOID,
                                                    BLOCK: feature.attributes.BLOCK,
                                                    TRACT: feature.attributes.TRACT,
                                                    STATE: feature.attributes.STATE,
                                                    COUNTY: feature.attributes.COUNTY,
                                                    POP100: feature.attributes.POP100,
                                                    STATEFP: feature.attributes.STATEFP,
                                                    COUNTYFP: feature.attributes.COUNTYFP
                                                }
                                            };
                                        }).filter(Boolean);

                                        console.log('[queryFeatures] Converted features:', convertedFeatures);
                                        resolve(convertedFeatures);
                                    } else {
                                        console.log('[queryFeatures] No valid features found');
                                        resolve([]);
                                    }
                                })
                                .catch(error => {
                                    console.error('[queryFeatures] Error processing census blocks:', error);
                                    resolve([]);
                                });
                            return;
                        }

                        if (maType === 'place') {
                            baseUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Places_CouSub_ConCity_SubMCD/MapServer/5/query";
                            
                            const params = new URLSearchParams({
                                f: 'json',
                                where: '1=1',
                                geometry: JSON.stringify({
                                    xmin: extent.xmin,
                                    ymin: extent.ymin,
                                    xmax: extent.xmax,
                                    ymax: extent.ymax,
                                    spatialReference: { wkid: 102100 }
                                }),
                                geometryType: 'esriGeometryEnvelope',
                                inSR: '102100',
                                outSR: '102100',
                                outFields: 'GEOID,NAME,STATE,LSADC,BASENAME',
                                returnGeometry: 'true',
                                spatialRel: 'esriSpatialRelIntersects'
                            });

                            console.log('Place query URL:', `${baseUrl}?${params.toString()}`);

                            fetch(`${baseUrl}?${params.toString()}`)
                                .then(response => response.json())
                                .then(data => {
                                    console.log('Places query response:', data);
                                    
                                    if (data.error) {
                                        console.error('TIGERweb error:', data.error);
                                        resolve([]);
                                        return;
                                    }

                                    if (data.features && Array.isArray(data.features) && data.features.length > 0) {
                                        console.log(`Found ${data.features.length} places`);
                                        
                                        const convertedFeatures = data.features.map(feature => {
                                            if (!feature.geometry || !feature.geometry.rings) {
                                                console.warn('Place feature missing geometry or rings:', feature);
                                                return null;
                                            }

                                            const polygon = new Polygon({
                                                rings: feature.geometry.rings,
                                                spatialReference: { wkid: 102100 }
                                            });

                                            return {
                                                attributes: {
                                                    GEOID: feature.attributes.GEOID,
                                                    NAME: feature.attributes.NAME,
                                                    STATE_NAME: feature.attributes.STATE,
                                                    PLACEFP: feature.attributes.GEOID.substring(2),
                                                    STATEFP: feature.attributes.GEOID.substring(0, 2),
                                                    LSADC: feature.attributes.LSADC,
                                                    type: 'place'
                                                },
                                                geometry: polygon
                                            };
                                        }).filter(Boolean);

                                        console.log('Converted features:', convertedFeatures);
                                        resolve(convertedFeatures);
                                    } else {
                                        console.log('No place features found');
                                        resolve([]);
                                    }
                                })
                                .catch(error => {
                                    console.error('Error querying places:', error);
                                    resolve([]);
                                });
                            return;
                        }

                        // Handle other types using standard query
                        switch(maType) {
                            case 'state':
                                baseUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_States_Generalized/FeatureServer/0";
                                break;
                            case 'usa':
                                baseUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Boundaries_2022/FeatureServer/0";
                                break;
                            case 'cbsa':
                                const cbsaLayers = [
                                    {
                                        url: "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/CBSA/MapServer/3",
                                        type: "metro"
                                    },
                                    {
                                        url: "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/CBSA/MapServer/4",
                                        type: "micro"
                                    },
                                    {
                                        url: "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/CBSA/MapServer/2",
                                        type: "division"
                                    }
                                ];

                                const cbsaParams = new URLSearchParams({
                                    f: 'json',
                                    where: isEditingOrCreating ? '1=1' : 
                                        `GEOID IN ('${marketAreas.find(ma => ma.type === 'cbsa')?.areas.map(a => a.cbsaId).join("','")}')`,
                                    geometry: JSON.stringify({
                                        xmin: extent.xmin,
                                        ymin: extent.ymin,
                                        xmax: extent.xmax,
                                        ymax: extent.ymax,
                                        spatialReference: { wkid: 102100 }
                                    }),
                                    geometryType: 'esriGeometryEnvelope',
                                    inSR: '102100',
                                    outSR: '102100',
                                    outFields: '*',
                                    returnGeometry: 'true',
                                    spatialRel: 'esriSpatialRelIntersects'
                                });

                                Promise.all(cbsaLayers.map(layer => 
                                    fetch(`${layer.url}/query?${cbsaParams.toString()}`)
                                        .then(response => response.json())
                                        .then(data => {
                                            if (data.error) {
                                                console.error(`CBSA ${layer.type} query error:`, data.error);
                                                return [];
                                            }

                                            if (data.features && Array.isArray(data.features)) {
                                                return data.features.map(feature => ({
                                                    attributes: {
                                                        ...feature.attributes,
                                                        CBSAFP: feature.attributes.GEOID || feature.attributes.CBSA,
                                                        NAME: feature.attributes.NAME,
                                                        BASENAME: feature.attributes.BASENAME,
                                                        cbsaType: layer.type,
                                                        type: 'cbsa'
                                                    },
                                                    geometry: new Polygon({
                                                        rings: feature.geometry.rings,
                                                        spatialReference: { wkid: 102100 }
                                                    })
                                                }));
                                            }
                                            return [];
                                        })
                                        .catch(error => {
                                            console.error(`Error querying CBSA ${layer.type}:`, error);
                                            return [];
                                        })
                                )).then(results => {
                                    const allFeatures = results.flat();
                                    console.log(`Found ${allFeatures.length} total CBSA features`);
                                    resolve(allFeatures);
                                }).catch(error => {
                                    console.error('Error in CBSA queries:', error);
                                    resolve([]);
                                });
                                return;
                            case 'tract':
                                baseUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Census2020/MapServer/6";
                                break;
                            case 'zip':
                                baseUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_ZIP_Codes/FeatureServer/0";
                                break;
                            case 'county':
                                baseUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Counties/FeatureServer/0";
                                break;
                            case 'drivetime':
                            case 'radius':
                                resolve([]);
                                return;
                            default:
                                console.error('Invalid maType:', maType);
                                resolve([]);
                                return;
                        }

                        queryParams = new Query({
                            geometry: extent,
                            outFields: ["*"],
                            returnGeometry: true,
                            outSpatialReference: { wkid: 102100 }
                        });

                        // Apply where clause if not in edit mode
                        if (!isEditingOrCreating) {
                            const ma = marketAreas.find(ma => ma.type === maType);
                            if (ma) {
                                switch(maType) {
                                    case 'state':
                                        queryParams.where = `STATE_NAME IN ('${ma.areas.map(a => a.name).join("','")}')`;
                                        break;
                                    case 'usa':
                                        queryParams.where = "1=1";
                                        break;
                                    case 'zip':
                                        queryParams.where = `ZIP IN ('${ma.areas.map(a => a.code).join("','")}')`;
                                        break;
                                    case 'county':
                                        queryParams.where = ma.areas.map(county => {
                                            const parts = county.fullName.split(',').map(part => part.trim());
                                            return `(NAME = '${parts[0]}' AND STATE_NAME = '${parts[1]}')`;
                                        }).join(" OR ");
                                        break;
                                    case 'tract':
                                        queryParams.where = `GEOID IN ('${ma.areas.map(a => a.geoid).join("','")}')`;
                                        break;
                                }
                            }
                        } else {
                            queryParams.where = "1=1";
                        }

                        console.log('Executing query with params:', queryParams);

                        query.executeQueryJSON(baseUrl, queryParams)
                            .then(results => {
                                if (results.features && results.features.length > 0) {
                                    console.log(`Query returned ${results.features.length} features for ${maType}`);
                                    resolve(results.features);
                                } else {
                                    console.log(`No features found for ${maType}`);
                                    resolve([]);
                                }
                            })
                            .catch(error => {
                                console.error("Error executing query:", error);
                                resolve([]);
                            });
                    });
                });
            }
            
            
                                // Update searchStates function
            async function searchStates(query) {
                try {
                    const url = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_States_Generalized/FeatureServer/0/query";
                    const params = new URLSearchParams({
                        where: `UPPER(STATE_NAME) LIKE UPPER('%${query}%')`,
                        outFields: "STATE_NAME,STATE_ABBR,STATE_FIPS",
                        returnDistinctValues: true,
                        returnGeometry: false,
                        orderByFields: "STATE_NAME",
                        f: "json"
                    });

                    const response = await fetch(`${url}?${params}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    if (data.features) {
                        availableLocations = data.features
                            .map(feature => ({
                                id: feature.attributes.STATE_NAME,
                                name: feature.attributes.STATE_NAME,
                                type: 'state',
                                stateAbbr: feature.attributes.STATE_ABBR,
                                fips: feature.attributes.STATE_FIPS
                            }))
                            .filter(state => !selectedLocations.some(selected => selected.id === state.id));
                    } else {
                        availableLocations = [];
                    }
                    
                    updateLocationLists();
                } catch (error) {
                    console.error('Error searching states:', error);
                    availableLocations = [];
                    updateLocationLists();
                }
            }

            async function searchUSA() {
                // For USA, we only ever have one option
                availableLocations = [{
                    id: 'USA',
                    name: 'United States of America',
                    type: 'usa'
                }].filter(usa => !selectedLocations.some(selected => selected.id === usa.id));
                updateLocationLists();
            }


            // Search for zip codes
            async function searchZipCodes(query) {
                // Use ArcGIS API to search for zip codes
                require(["esri/request"], function(esriRequest) {
                    const url = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_ZIP_Codes/FeatureServer/0/query";
                    const params = {
                        where: `ZIP LIKE '${query}%'`,
                        outFields: "ZIP",
                        returnDistinctValues: true,
                        returnGeometry: false,
                        orderByFields: "ZIP",
                        f: "json"
                    };

                    esriRequest(url, {
                        query: params
                    }).then(response => {
                        availableLocations = response.data.features
                            .map(feature => ({
                                id: feature.attributes.ZIP,
                                name: feature.attributes.ZIP,
                                type: 'zip'
                            }))
                            .filter(zip => !selectedLocations.some(selected => selected.id === zip.id));
                        updateLocationLists();
                    });
                });
            }

            // Search for counties
            async function searchCounties(query) {
                require(["esri/request"], function(esriRequest) {
                    const url = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Counties/FeatureServer/0/query";
                    const params = {
                        where: `NAME LIKE '%${query}%'`,
                        outFields: "NAME,STATE_NAME",
                        returnDistinctValues: true,
                        returnGeometry: false,
                        orderByFields: "STATE_NAME,NAME",
                        f: "json"
                    };

                    esriRequest(url, {
                        query: params
                    }).then(response => {
                        availableLocations = response.data.features
                            .map(feature => ({
                                id: `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`,
                                name: `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`,
                                type: 'county'
                            }))
                            .filter(county => !selectedLocations.some(selected => selected.id === county.id));
                        updateLocationLists();
                    });
                });
            }

            function formatLocationName(location) {
                console.log('[formatLocationName] Processing location:', location);

                if (location.type === 'blockgroup') {
                    // Try to get the block group ID and tract ID from all possible sources
                    const blockGroupId = location.blockGroupId || location.BLKGRP || 
                        (location.geoid ? location.geoid.slice(-1) : undefined);
                    const tractId = location.tractId || location.TRACT || 
                        (location.geoid ? location.geoid.slice(5, 11) : undefined);
                    const population = location.population || location.POP100;

                    if (blockGroupId && tractId) {
                        let displayName = `Block Group ${blockGroupId}, Tract ${tractId}`;
                        if (population) {
                            displayName += ` (Pop: ${population.toLocaleString()})`;
                        }
                        return displayName;
                    }

                    // Fallback to ID if we can't format it properly
                    return location.id || location.geoid || 'Unnamed Block Group';
                }

                return location.name || 'Unnamed Location';
            }

            function updateLocationLists() {
                console.log('[updateLocationLists] Starting update');
                
                const availableContainer = document.getElementById('availableLocations');
                const selectedContainer = document.getElementById('selectedLocations');

                if (!availableContainer || !selectedContainer) {
                    console.error('[updateLocationLists] Containers not found');
                    return;
                }

                console.log('[updateLocationLists] Current locations:', {
                    available: availableLocations,
                    selected: selectedLocations
                });

                // Update available locations
                availableContainer.innerHTML = availableLocations.map(location => {
                    const displayName = formatLocationName(location);
                    console.log('[updateLocationLists] Formatted available location:', {
                        original: location,
                        formatted: displayName
                    });

                    return `
                        <div class="location-item" data-id="${location.id}" 
                            data-geoid="${location.geoid || ''}" data-type="${location.type}">
                            <label style="display: flex; align-items: center; width: 100%;">
                                <input type="checkbox" class="location-checkbox" style="margin-right: 8px;">
                                <div style="flex: 1;">${displayName}</div>
                            </label>
                        </div>
                    `;
                }).join('');

                // Update selected locations
                selectedContainer.innerHTML = selectedLocations.map(location => {
                    const displayName = formatLocationName(location);
                    console.log('[updateLocationLists] Formatted selected location:', {
                        original: location,
                        formatted: displayName
                    });

                    return `
                        <div class="location-item" data-id="${location.id}" 
                            data-geoid="${location.geoid || ''}" data-type="${location.type}">
                            <label style="display: flex; align-items: center; width: 100%;">
                                <input type="checkbox" class="location-checkbox" style="margin-right: 8px;">
                                <div style="flex: 1;">${displayName}</div>
                            </label>
                        </div>
                    `;
                }).join('');

                // Update the selected count
                const selectedCount = document.getElementById('selectedLocationsCount');
                if (selectedCount) {
                    selectedCount.textContent = `(${selectedLocations.length} selected)`;
                }

                console.log('[updateLocationLists] Update complete');
            }



            // Add this helper function to check if elements exist
            function ensureFormElements() {
                const requiredElements = [
                    'ma-form',
                    'ma-list',
                    'maType',
                    'maName',
                    'shortName',
                    'acsCheckbox',
                    'transparency',
                    'transparencyValue',
                    'borderWeight',
                    'noBorder',
                    'fillColor',
                    'borderColor'
                ];

                const missingElements = requiredElements.filter(id => !document.getElementById(id));
                if (missingElements.length > 0) {
                    console.error('Missing required form elements:', missingElements);
                    return false;
                }
                return true;
            }


            // Initialize variables for the export functionality
            let availableVariables = [];
            let selectedVariables = [];

            // Update the exportData function to initialize the dialog when it's opened
            function exportData() {
                if (marketAreas.length === 0) {
                    alert("No market areas defined. Please create at least one market area before exporting.");
                    return;
                }

                // Show export dialog
                const dialog = document.getElementById('exportDialog');
                dialog.style.display = 'block';

                // Populate market areas list
                const maList = document.getElementById('maCheckboxList');
                if (maList) {
                    maList.innerHTML = marketAreas.map(ma => `
                        <div style="margin-bottom: 8px;">
                            <label style="display: flex; align-items: center;">
                                <input type="checkbox" class="ma-checkbox" value="${ma.id}" checked>
                                <span style="margin-left: 8px;">${ma.name} (${ma.type.toUpperCase()})</span>
                            </label>
                        </div>
                    `).join('');
                }

                // Initialize variables lists
                initializeVariableLists();

                // Initialize the dialog functionality
                initializeExportDialog();
            }

            // Initialize the variables lists
            function initializeVariableLists() {
                // Get all variables from the base preset
                fetch('/api/presets/base')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Start with all variables in the selected list
                            selectedVariables = [...data.variables];
                            availableVariables = [];
                            updateVariableLists();
                        }
                    })
                    .catch(error => console.error('Error loading variables:', error));
            }

            // Update the lists with proper aria labels for accessibility
            function updateVariableLists() {
                const availableList = document.getElementById('availableVariables');
                const selectedList = document.getElementById('selectedVariables');
                
                // Clear select all checkboxes
                const selectAllAvailable = document.getElementById('selectAllAvailable');
                const selectAllSelected = document.getElementById('selectAllSelected');
                if (selectAllAvailable) {
                    selectAllAvailable.checked = false;
                    selectAllAvailable.indeterminate = false;
                }
                if (selectAllSelected) {
                    selectAllSelected.checked = false;
                    selectAllSelected.indeterminate = false;
                }

                // Update available variables list
                availableList.innerHTML = availableVariables.map(variable => `
                    <div class="variable-item" data-variable="${variable}" style="display: flex; align-items: center; margin-bottom: 4px;">
                        <label style="display: flex; align-items: center; width: 100%;" aria-label="${variable}">
                            <input type="checkbox" class="variable-checkbox" style="margin-right: 8px;">
                            <span style="flex: 1;">${variable}</span>
                        </label>
                    </div>
                `).join('');

                // Update selected variables list
                selectedList.innerHTML = selectedVariables.map(variable => `
                    <div class="variable-item" data-variable="${variable}" style="display: flex; align-items: center; margin-bottom: 4px;">
                        <label style="display: flex; align-items: center; width: 100%;" aria-label="${variable}">
                            <input type="checkbox" class="variable-checkbox" style="margin-right: 8px;">
                            <span style="flex: 1;">${variable}</span>
                        </label>
                    </div>
                `).join('');

                // Apply current search filter and update select all states
                filterVariables();
            }
            // First, add this function to initialize the event listeners
            function setupExportDialogListeners() {
                // Setup select all functionality for Available Variables
                const selectAllAvailable = document.getElementById('selectAllAvailable');
                if (selectAllAvailable) {
                    selectAllAvailable.addEventListener('change', function() {
                        const checkboxes = document.querySelectorAll('#availableVariables input[type="checkbox"]:not(:disabled)');
                        checkboxes.forEach(checkbox => checkbox.checked = this.checked);
                    });
                }

                // Setup select all functionality for Selected Variables
                const selectAllSelected = document.getElementById('selectAllSelected');
                if (selectAllSelected) {
                    selectAllSelected.addEventListener('change', function() {
                        const checkboxes = document.querySelectorAll('#selectedVariables input[type="checkbox"]:not(:disabled)');
                        checkboxes.forEach(checkbox => checkbox.checked = this.checked);
                    });
                }

                // Setup search functionality
                const searchInput = document.getElementById('variableSearch');
                if (searchInput) {
                    searchInput.addEventListener('input', filterVariables);
                }
            }

            // Create a new function to initialize all export dialog functionality
            function initializeExportDialog() {
                // Get the dialog element
                const dialog = document.getElementById('exportDialog');
                if (!dialog) {
                    console.error('Export dialog not found');
                    return;
                }

                // Setup search input event listener
                const searchInput = document.getElementById('variableSearch');
                if (searchInput) {
                    searchInput.addEventListener('input', filterVariables);
                }

                // Setup "Select All" checkboxes
                setupSelectAllCheckboxes();
            }

            // Update the select all checkbox functionality
            function setupSelectAllCheckboxes() {
                const selectAllAvailable = document.getElementById('selectAllAvailable');
                const selectAllSelected = document.getElementById('selectAllSelected');
                const selectAllMAs = document.getElementById('selectAllMAs');

                if (selectAllAvailable) {
                    selectAllAvailable.addEventListener('change', function() {
                        // Only select checkboxes in visible items
                        const checkboxes = document.querySelectorAll('#availableVariables .variable-item:not([style*="display: none"]) input[type="checkbox"]');
                        checkboxes.forEach(checkbox => checkbox.checked = this.checked);
                    });
                }

                if (selectAllSelected) {
                    selectAllSelected.addEventListener('change', function() {
                        // Only select checkboxes in visible items
                        const checkboxes = document.querySelectorAll('#selectedVariables .variable-item:not([style*="display: none"]) input[type="checkbox"]');
                        checkboxes.forEach(checkbox => checkbox.checked = this.checked);
                    });
                }

                if (selectAllMAs) {
                    selectAllMAs.addEventListener('change', function() {
                        const checkboxes = document.querySelectorAll('.ma-checkbox');
                        checkboxes.forEach(cb => cb.checked = this.checked);
                    });
                }
            }

            // Update the filter function to handle select all state
            function filterVariables() {
                const searchInput = document.getElementById('variableSearch');
                if (!searchInput) return;

                const searchTerm = searchInput.value.toLowerCase();
                const availableList = document.getElementById('availableVariables');
                const selectedList = document.getElementById('selectedVariables');
                
                function filterList(list, selectAllCheckboxId) {
                    if (!list) return;
                    
                    let visibleCount = 0;
                    let checkedVisibleCount = 0;
                    
                    Array.from(list.children).forEach(item => {
                        const variableName = item.textContent.toLowerCase();
                        const isVisible = variableName.includes(searchTerm);
                        item.style.display = isVisible ? 'block' : 'none';
                        
                        if (isVisible) {
                            visibleCount++;
                            if (item.querySelector('input[type="checkbox"]').checked) {
                                checkedVisibleCount++;
                            }
                        }
                    });
                    
                    // Update select all checkbox state
                    const selectAllCheckbox = document.getElementById(selectAllCheckboxId);
                    if (selectAllCheckbox && visibleCount > 0) {
                        selectAllCheckbox.checked = visibleCount === checkedVisibleCount;
                        // Set indeterminate state if some but not all visible items are checked
                        selectAllCheckbox.indeterminate = checkedVisibleCount > 0 && checkedVisibleCount < visibleCount;
                    }
                }
                
                filterList(availableList, 'selectAllAvailable');
                filterList(selectedList, 'selectAllSelected');
            }

            // Update the move functions to maintain select all state
            function moveSelectedVariables(direction) {
                const sourceList = direction === 'right' ? 'availableVariables' : 'selectedVariables';
                const sourceArray = direction === 'right' ? availableVariables : selectedVariables;
                const targetArray = direction === 'right' ? selectedVariables : availableVariables;

                // Only get checked checkboxes from visible items
                const selectedCheckboxes = document.querySelectorAll(`#${sourceList} .variable-item:not([style*="display: none"]) input:checked`);
                let moved = false;
                
                selectedCheckboxes.forEach(checkbox => {
                    const variableItem = checkbox.closest('.variable-item');
                    const variable = variableItem.dataset.variable;
                    
                    if (direction === 'right') {
                        const index = availableVariables.indexOf(variable);
                        if (index !== -1) {
                            availableVariables.splice(index, 1);
                            selectedVariables.push(variable);
                            moved = true;
                        }
                    } else {
                        const index = selectedVariables.indexOf(variable);
                        if (index !== -1) {
                            selectedVariables.splice(index, 1);
                            availableVariables.push(variable);
                            moved = true;
                        }
                    }
                });

                if (moved) {
                    updateVariableLists();
                    // Reapply current search filter and update select all states
                    filterVariables();
                }
            }

            function showSaveAsDialog(defaultFilename) {
                return new Promise((resolve) => {
                    try {
                        // Modern approach using file system access API
                        const fileInput = document.createElement('input');
                        fileInput.type = 'file';
                        fileInput.style.display = 'none';
                        fileInput.setAttribute('nwsaveas', defaultFilename);
                        fileInput.setAttribute('accept', '.xlsx');

                        document.body.appendChild(fileInput);
                        
                        fileInput.addEventListener('change', function() {
                            const savePath = this.value;
                            document.body.removeChild(fileInput);
                            resolve(savePath);
                        });
                        
                        fileInput.addEventListener('cancel', function() {
                            document.body.removeChild(fileInput);
                            resolve(null);
                        });
                        
                        fileInput.click();
                    } catch (error) {
                        // Fallback to just using the default filename
                        resolve(defaultFilename);
                    }
                });
            }
            async function executeExport() {
                try {
                    // Get the export name from dialog input
                    const exportName = document.getElementById('exportName').value || 'market_areas_analysis';
                    const filename = `${exportName}.xlsx`;

                    const selectedMAs = Array.from(document.querySelectorAll('.ma-checkbox:checked'))
                        .map(cb => marketAreas.find(ma => ma.id === parseInt(cb.value)))
                        .filter(ma => ma);

                    if (selectedMAs.length === 0) {
                        alert('Please select at least one market area to export.');
                        return;
                    }

                    // Close the export dialog immediately
                    closeExportDialog();
                    
                    // Show the status indicator
                    showExportStatus(true);

                    // Format study areas with proper structure for backend
                    const studyAreas = selectedMAs.map(ma => {
                        let formattedArea = {
                            name: ma.name,
                            shortName: ma.shortName || '',
                            type: ma.type,
                            areas: []
                        };

                        if (ma.type === 'zip') {
                            formattedArea.areas = ma.areas.map(area => ({
                                code: area.code,
                                areaIncluded: area.code
                            }));
                            formattedArea.areaIncluded = ma.areas.map(a => a.code).join(', ');
                        } else if (ma.type === 'county') {
                            formattedArea.areas = ma.areas.map(area => {
                                let countyName, stateName;
                                if (area.fullName) {
                                    const parts = area.fullName.split(',').map(p => p.trim());
                                    countyName = parts[0].replace(/\s+County$/i, '');
                                    stateName = parts[1];
                                } else {
                                    countyName = area.name;
                                    stateName = area.state;
                                }
                                
                                return {
                                    name: countyName,
                                    state: stateName,
                                    fullName: `${countyName} County, ${stateName}`,
                                    fipsCode: area.fipsCode
                                };
                            });
                            formattedArea.areaIncluded = formattedArea.areas.map(a => a.fullName).join('; ');
                            formattedArea.fips = formattedArea.areas[0]?.fipsCode || '';
                        }

                        return formattedArea;
                    });

                    // Make enrichment request
                    const response = await fetch('/enrich-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            study_areas: studyAreas,
                            variables: selectedVariables,
                            exportType: 'excel',
                            filename: filename,
                            includeMetadata: true // Add this flag to include metadata in response
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    // Update status during file processing
                    showExportStatus(true, 'Processing data...', 'Preparing your export file');

                    // Get the blob from the response
                    const blob = await response.blob();

                    // Update status for download
                    showExportStatus(true, 'Download starting...', 'Your file will download automatically');

                    // Create download link and trigger download
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);

                    // Show success message briefly
                    showExportStatus(true, 'Export complete!', 'Your file has been downloaded');
                    setTimeout(() => {
                        showExportStatus(false);
                    }, 3000);

                } catch (error) {
                    console.error('Export error:', error);
                    showExportStatus(true, 'Export failed', 'Please try again');
                    setTimeout(() => {
                        showExportStatus(false);
                    }, 3000);
                    alert('Error during export. Please try again.');
                }
            }




            function loadArcGISAPI() {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://js.arcgis.com/4.24/';
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            // Update searchLocations for census tracts
            async function searchLocations(query) {
                console.log('Searching locations with query:', query);
                
                require(["esri/request"], function(esriRequest) {
                    const maType = document.getElementById('maType').value;
                    let url, params;

                    if (maType === 'tract') {
                        // Use Census Tracts 2020 feature service
                        url = "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Census_Tracts_2020/FeatureServer/0/query";
                        params = {
                            where: query.match(/^\d+$/) ? 
                                `TRACTCE20 LIKE '${query}%'` : // Search by tract number
                                `(NAMELSAD20 LIKE '%${query}%' OR STATE_NAME LIKE '%${query}%')`, // Search by name
                            outFields: "TRACTCE20,NAMELSAD20,STATE_NAME,COUNTYFP20,STATEFP20,GEOID20",
                            returnDistinctValues: true,
                            returnGeometry: false,
                            orderByFields: "STATE_NAME,NAMELSAD20",
                            f: "json"
                        };
                    } else if (maType === 'zip') {
                        // Existing ZIP code logic...
                        url = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_ZIP_Codes/FeatureServer/0";
                        params = {
                            where: `ZIP LIKE '${query}%'`,
                            outFields: "ZIP",
                            returnDistinctValues: true,
                            returnGeometry: false,
                            orderByFields: "ZIP",
                            f: "json"
                        };
                    } else {
                        // Existing county logic...
                        url = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Counties/FeatureServer/0";
                        params = {
                            where: `NAME LIKE '%${query}%'`,
                            outFields: "NAME,STATE_NAME",
                            returnDistinctValues: true,
                            returnGeometry: false,
                            orderByFields: "STATE_NAME,NAME",
                            f: "json"
                        };
                    }

                    esriRequest(url, {
                        query: params
                    }).then(response => {
                        console.log('Search response:', response);
                        
                        if (maType === 'tract') {
                            availableLocations = response.data.features
                                .map(feature => ({
                                    id: feature.attributes.GEOID20,
                                    name: `Census Tract ${feature.attributes.TRACTCE20}, ${feature.attributes.NAMELSAD20}, ${feature.attributes.STATE_NAME}`,
                                    type: 'tract',
                                    tractId: feature.attributes.TRACTCE20,
                                    stateId: feature.attributes.STATEFP20,
                                    countyId: feature.attributes.COUNTYFP20,
                                    geoid: feature.attributes.GEOID20
                                }))
                                .filter(tract => !selectedLocations.some(selected => selected.id === tract.id));
                        } else if (maType === 'zip') {
                            // Existing ZIP code mapping...
                            availableLocations = response.data.features
                                .map(feature => ({
                                    id: feature.attributes.ZIP,
                                    name: feature.attributes.ZIP,
                                    type: 'zip'
                                }))
                                .filter(zip => !selectedLocations.some(selected => selected.id === zip.id));
                        } else {
                            // Existing county mapping...
                            availableLocations = response.data.features
                                .map(feature => ({
                                    id: `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`,
                                    name: `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`,
                                    type: 'county'
                                }))
                                .filter(county => !selectedLocations.some(selected => selected.id === county.id));
                        }
                        updateLocationLists();
                    }).catch(error => {
                        console.error('Search error:', error);
                    });
                });
            }

            // Add a function to get place details
            async function getPlaceDetails(placeId) {
                try {
                    const response = await fetch(`/places/${placeId}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to get place details: ${response.statusText}`);
                    }

                    const data = await response.json();
                    return data.placeDetails;
                } catch (error) {
                    console.error('Error getting place details:', error);
                    return null;
                }
            }

            // Add a debounce wrapper for the search function
            let searchPlacesTimeout = null;

            async function debouncedSearchPlaces(query) {
                // Clear any existing timeout
                if (searchPlacesTimeout) {
                    clearTimeout(searchPlacesTimeout);
                }

                // Return a promise that resolves when the search is complete
                return new Promise((resolve) => {
                    searchPlacesTimeout = setTimeout(async () => {
                        try {
                            // Get current map center if available
                            let lat = '34.0522';  // Default to LA
                            let lon = '-118.2437';
                            
                            if (mapViewInstance && mapViewInstance.center) {
                                lat = mapViewInstance.center.latitude;
                                lon = mapViewInstance.center.longitude;
                            }

                            const searchUrl = `/places/search?q=${encodeURIComponent(query)}&lat=${lat}&lon=${lon}`;
                            console.log('Searching places with URL:', searchUrl);

                            const response = await fetch(searchUrl, {
                                method: 'GET',
                                headers: {
                                    'Content-Type': 'application/json'
                                }
                            });

                            if (!response.ok) {
                                const errorText = await response.text();
                                console.error('Places API Response:', errorText);
                                throw new Error(`Places search failed: ${response.statusText}`);
                            }

                            const data = await response.json();
                            
                            if (data.error) {
                                console.error('Places API error:', data.error);
                                availableLocations = [];
                                updateLocationLists();
                                resolve();
                                return;
                            }

                            // Extract results from the response
                            const places = data.results || [];
                            console.log('Found places:', places);

                            // Convert places to our standard format
                            availableLocations = places.map(place => {
                                const address = place.address || {};
                                const addressString = address.streetAddress || 
                                                    address.formattedAddress || 
                                                    [address.locality, address.region].filter(Boolean).join(', ') || 
                                                    'No address';
                                
                                return {
                                    id: place.placeId || `${place.location.x},${place.location.y}`,
                                    name: `${place.name} - ${addressString}`,
                                    type: 'place',
                                    location: place.location,
                                    placeData: place  // Store all place data for later use
                                };
                            }).filter(place => !selectedLocations.some(selected => selected.id === place.id));

                            console.log('Processed locations:', availableLocations);
                            updateLocationLists();
                            resolve();

                        } catch (error) {
                            console.error('Error searching places:', error);
                            availableLocations = [];
                            updateLocationLists();
                            resolve();
                        }
                    }, 500); // 500ms delay
                });
            }

            
            // Update handleLocationSearch to include new types
            async function handleLocationSearch(event) {
                const query = event.target.value.trim();
                console.log('Handling location search for query:', query);
                    
                if (query.length < 2) {
                    console.log('Query too short, clearing results');
                    availableLocations = [];
                    updateLocationLists();
                    return;
                }

                const maType = document.getElementById('maType').value;
                console.log('Searching for type:', maType);

                try {
                    switch(maType) {
                        case 'block':
                            await searchCensusBlocks(query);
                            break;
                        case 'blockgroup':
                            await searchBlockGroups(query);
                            break;
                        case 'state':
                            await searchStates(query);
                            break;
                        case 'usa':
                            await searchUSA();
                            break;
                        case 'place':
                            await searchPlaces(query);
                            break;
                        case 'tract':
                            await searchCensusTracts(query);
                            break;
                        case 'zip':
                            await searchZipCodes(query);
                            break;
                        case 'county':
                            await searchCounties(query);
                            break;
                        case 'cbsa':
                            await searchCBSA(query);
                            break;
                        default:
                            console.warn('Unknown location type:', maType);
                            availableLocations = [];
                            updateLocationLists();
                    }
                } catch (error) {
                    console.error('Error in location search:', error);
                    availableLocations = [];
                    updateLocationLists();
                }
            }


            // Add proper highlighting for states
            function updateStateGraphics(feature, ma) {
                return new Graphic({
                    geometry: feature.geometry,
                    symbol: {
                        type: "simple-fill",
                        color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                        outline: ma.borderWeight > 0 ? {
                            color: ma.borderColor,
                            width: ma.borderWeight
                        } : null
                    },
                    attributes: {
                        id: ma.id,
                        name: ma.name,
                        type: 'state',
                        stateName: feature.attributes.STATE_NAME,
                        stateAbbr: feature.attributes.STATE_ABBR,
                        fips: feature.attributes.STATE_FIPS
                    }
                });
            }

            let layers = {
                boundaryLayer: null,
                labelLayer: null,
                highlightLayer: null
            };

            // Update the initializeMap function to include highway shields
            async function initializeMap(isFirstLoad) {
                try {
                    await loadArcGISAPI();
                    
                    return new Promise((resolve, reject) => {
                        require([
                            "esri/Map",
                            "esri/views/MapView",
                            "esri/layers/GraphicsLayer",
                            "esri/widgets/ScaleBar",
                            "esri/config",
                            "esri/layers/VectorTileLayer"
                        ], function(Map, MapView, GraphicsLayer, ScaleBar, esriConfig, VectorTileLayer) {
                            // Set the API key
                            esriConfig.apiKey = ARCGIS_API_KEY;

                            // Create custom vector tile layer with highway shields
                            const vectorTileLayer = new VectorTileLayer({
                                url: "https://www.arcgis.com/sharing/rest/content/items/7675d44bb1e4428aa2c30a9b68f97822/resources/styles/root.json",
                                style: {
                                    "version": 8,
                                    "sources": {
                                        "esri": {
                                            "type": "vector",
                                            "url": "https://basemaps.arcgis.com/arcgis/rest/services/World_Basemap_v2/VectorTileServer"
                                        }
                                    },
                                    "layers": [
                                        {
                                            "id": "highway-shields",
                                            "type": "symbol",
                                            "source": "esri",
                                            "source-layer": "Road/label",
                                            "filter": ["any",
                                                ["==", "shield", "interstate"],
                                                ["==", "shield", "us"],
                                                ["==", "shield", "state"]
                                            ],
                                            "layout": {
                                                "icon-image": "{shield}-{reflen}",
                                                "icon-rotation-alignment": "viewport",
                                                "icon-size": 1,
                                                "symbol-placement": "line",
                                                "text-field": "{ref}",
                                                "text-font": ["Arial Regular"],
                                                "text-rotation-alignment": "viewport",
                                                "text-size": 12
                                            },
                                            "paint": {
                                                "text-color": [
                                                    "match",
                                                    ["get", "shield"],
                                                    "interstate", "#ffffff",
                                                    "us", "#000000",
                                                    "state", "#000000",
                                                    "#000000"
                                                ]
                                            }
                                        }
                                    ]
                                }
                            });

                            const map = new Map({
                                basemap: "streets-navigation-vector",
                                layers: [vectorTileLayer]
                            });

                            layers.boundaryLayer = new GraphicsLayer({ id: "boundaryLayer" });
                            layers.labelLayer = new GraphicsLayer({ id: "labelLayer" });
                            layers.highlightLayer = new GraphicsLayer({ id: "highlightLayer" });

                            map.addMany([layers.boundaryLayer, layers.labelLayer, layers.highlightLayer]);

                            mapViewInstance = new MapView({
                                container: "mapDiv",
                                map: map,
                                zoom: 10,
                                center: [-118.2437, 34.0522], // Default to LA
                                spatialReference: { wkid: 102100 },
                                constraints: {
                                    snapToZoom: false
                                }
                            });

                            // Only get user's location on first load if no previous center exists
                            if (isFirstLoad && !localStorage.getItem('lastMapCenter')) {
                                if (navigator.geolocation) {
                                    navigator.geolocation.getCurrentPosition(
                                        (position) => {
                                            const center = [position.coords.longitude, position.coords.latitude];
                                            mapViewInstance.center = center;
                                            localStorage.setItem('lastMapCenter', JSON.stringify(center));
                                        },
                                        () => {
                                            // Fallback to default center if geolocation fails
                                            const defaultCenter = [-118.2437, 34.0522];
                                            mapViewInstance.center = defaultCenter;
                                            localStorage.setItem('lastMapCenter', JSON.stringify(defaultCenter));
                                        }
                                    );
                                }
                            } else if (!isFirstLoad && localStorage.getItem('lastMapCenter')) {
                                const lastCenter = JSON.parse(localStorage.getItem('lastMapCenter'));
                                mapViewInstance.center = lastCenter;
                            }

                            const scaleBar = new ScaleBar({
                                view: mapViewInstance,
                                unit: "imperial",
                                style: "line"
                            });
                            mapViewInstance.ui.add(scaleBar, "bottom-right");

                            mapViewInstance.when(() => {
                                console.log("Map and View are ready");
                                initializeMapEvents();
                                resolve(mapViewInstance);
                            }).catch(reject);
                        });
                    });
                } catch (error) {
                    console.error("Error in map initialization:", error);
                    throw error;
                }
            }


            // Add this to your PLACES_CONFIG
            const PLACES_CONFIG = {
                MAX_RESULTS: 20,
                MIN_QUERY_LENGTH: 2,
                DEBOUNCE_DELAY: 500,
                DEFAULT_RADIUS: 5000,
                CENTER_MARKER_SIZE: 12
            };

            // Helper function for LSAD codes (unchanged)
            function getLSADLabel(lsad) {
                const lsadCodes = {
                    '00': 'Undefined',
                    '03': 'City',
                    '04': 'Borough',
                    '05': 'Census Designated Place',
                    '06': 'City and Borough',
                    '07': 'Municipality',
                    '10': 'Town',
                    '12': 'Township',
                    '13': 'Village',
                    '15': 'Unified Government',
                    '21': 'Borough (Alaska)',
                    '25': 'City and Township',
                    '37': 'Municipality (Alaska)',
                    '47': 'Village (Alaska)',
                    '62': 'Zona Urbana'
                };
                return lsadCodes[lsad] || 'Place';
            }


            function ensureWebMercator(feature) {
                if (feature.geometry) {
                    if (!feature.geometry.spatialReference) {
                        feature.geometry.spatialReference = { wkid: 102100 };
                    } else if (feature.geometry.spatialReference.wkid === 4326) {
                        // Convert from geographic to Web Mercator if needed
                        require(["esri/geometry/support/webMercatorUtils"], function(webMercatorUtils) {
                            const mercGeom = webMercatorUtils.geographicToWebMercator(feature.geometry);
                            feature.geometry = mercGeom;
                        });
                    }
                }
                return feature;
            }


            // Update the searchPlaces function to remove radius-related code
            async function searchPlaces(query) {
                console.log('Starting Places search with query:', query);
                
                // Use TIGERweb Census Places API
                const baseUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Places_CouSub_ConCity_SubMCD/MapServer/0/query";
                
                try {
                    // Build query parameters
                    const params = {
                        f: 'json',
                        where: `UPPER(NAME) LIKE UPPER('%${query.replace(/['"\\]/g, '')}%') AND POP100 > 0`,
                        outFields: 'GEOID,NAME,STATE_NAME,PLACEFP,STATEFP,POP100,LSAD',
                        returnGeometry: false,
                        orderByFields: 'STATE_NAME,NAME',
                        returnDistinctValues: true
                    };

                    // Convert params to URL search params
                    const searchParams = new URLSearchParams();
                    Object.entries(params).forEach(([key, value]) => {
                        searchParams.append(key, value);
                    });

                    const url = `${baseUrl}?${searchParams.toString()}`;
                    console.log('Census Places API Request URL:', url);

                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    console.log('Census Places search response:', data);

                    if (data.features && data.features.length > 0) {
                        availableLocations = data.features
                            .map(feature => {
                                const attrs = feature.attributes;
                                const lsadLabel = getLSADLabel(attrs.LSAD);
                                const popInfo = attrs.POP100 ? ` (Pop: ${attrs.POP100.toLocaleString()})` : '';

                                return {
                                    id: attrs.GEOID,
                                    name: `${attrs.NAME}, ${attrs.STATE_NAME} - ${lsadLabel}${popInfo}`,
                                    type: 'place',
                                    placeId: attrs.PLACEFP,
                                    stateId: attrs.STATEFP,
                                    geoid: attrs.GEOID,
                                    population: attrs.POP100,
                                    lsad: attrs.LSAD,
                                    stateName: attrs.STATE_NAME
                                };
                            })
                            .filter(place => !selectedLocations.some(selected => selected.id === place.id));

                        console.log('Processed places:', availableLocations);
                    } else {
                        console.log('No places found for query:', query);
                        availableLocations = [];
                    }
                    
                    updateLocationLists();

                } catch (error) {
                    console.error('Error searching Census Places:', error);
                    availableLocations = [];
                    updateLocationLists();
                }
            }


            // Update the createPlaceGraphic function to properly handle place features
            function createPlaceGraphic(feature, ma) {
                if (!feature.geometry || !feature.geometry.rings) {
                    console.warn('Invalid place geometry:', feature);
                    return null;
                }

                return {
                    geometry: feature.geometry,
                    symbol: {
                        type: "simple-fill",
                        color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                        outline: ma.borderWeight > 0 ? {
                            color: ma.borderColor,
                            width: ma.borderWeight
                        } : null
                    },
                    attributes: {
                        id: feature.attributes.GEOID,
                        name: feature.attributes.NAME,
                        type: 'place',
                        geoid: feature.attributes.GEOID,
                        placeId: feature.attributes.PLACEFP,
                        stateId: feature.attributes.STATEFP,
                        lsad: feature.attributes.LSADC,
                        stateName: feature.attributes.STATE_NAME
                    }
                };
            }

            // Helper function to convert Web Mercator to Geographic coordinates properly
            function webMercatorToGeographic(point) {
                try {
                    // Use esri conversion utilities for proper handling
                    return new Promise((resolve, reject) => {
                        require([
                            "esri/geometry/support/webMercatorUtils",
                            "esri/geometry/Point"
                        ], function(webMercatorUtils, Point) {
                            // Create a proper Point geometry with spatial reference
                            const webMercatorPoint = new Point({
                                x: point.x,
                                y: point.y,
                                spatialReference: { wkid: 102100 }
                            });

                            // Convert to geographic coordinates
                            const geographicPoint = webMercatorUtils.webMercatorToGeographic(webMercatorPoint);
                            
                            resolve({
                                longitude: geographicPoint.x,
                                latitude: geographicPoint.y
                            });
                        });
                    });
                } catch (error) {
                    console.error('Error converting coordinates:', error);
                    return null;
                }
            }


            // Update the visual indicator for search center
            function updateSearchCenterMarker(center) {
                if (!mapViewInstance || !layers.highlightLayer) return;

                require([
                    "esri/Graphic",
                    "esri/geometry/Point",
                    "esri/symbols/SimpleMarkerSymbol"
                ], function(Graphic, Point, SimpleMarkerSymbol) {
                    // Remove existing center marker
                    layers.highlightLayer.graphics.filter(g => g.attributes?.type === 'search-center')
                        .forEach(g => layers.highlightLayer.remove(g));

                    // Create new center marker
                    const centerPoint = new Point({
                        longitude: center.longitude,
                        latitude: center.latitude,
                        spatialReference: { wkid: 4326 }
                    });

                    const centerMarker = new Graphic({
                        geometry: centerPoint,
                        symbol: new SimpleMarkerSymbol({
                            style: "circle",
                            color: [0, 0, 255, 0.5],
                            size: PLACES_CONFIG.CENTER_MARKER_SIZE,
                            outline: {
                                color: [255, 255, 255],
                                width: 2
                            }
                        }),
                        attributes: {
                            type: 'search-center'
                        }
                    });

                    layers.highlightLayer.add(centerMarker);
                });
            }


            // Add this function to handle map resizing
            function handleMapResize() {
                if (mapViewInstance) {
                    try {
                        // Check if resize is a function before calling it
                        if (typeof mapViewInstance.resize === 'function') {
                            mapViewInstance.resize();
                        } else if (mapViewInstance.view && typeof mapViewInstance.view.resize === 'function') {
                            mapViewInstance.view.resize();
                        }
                    } catch (error) {
                        console.warn('Error resizing map:', error);
                    }
                }
            }

            // Update the window resize listener
            window.addEventListener('resize', debounce(() => {
                handleMapResize();
            }, 250));

            // Update the updateMapCenterTracking function to remove radius visualization for places
            function updateMapCenterTracking() {
                if (!mapViewInstance) return;

                // Remove existing watch handle
                if (mapViewInstance.centerWatchHandle) {
                    mapViewInstance.centerWatchHandle.remove();
                }

                mapViewInstance.centerWatchHandle = mapViewInstance.watch('center', debounce(async (center) => {
                    if (!center) return;

                    try {
                        const geographicCenter = await webMercatorToGeographic(center);
                        if (geographicCenter) {
                            console.log('Map center updated:', {
                                longitude: geographicCenter.longitude,
                                latitude: geographicCenter.latitude
                            });

                            // Store the last center position
                            localStorage.setItem('lastMapCenter', JSON.stringify([
                                geographicCenter.longitude,
                                geographicCenter.latitude
                            ]));

                            // Places don't need radius visualization anymore
                            const maType = document.getElementById('maType')?.value;
                            if (maType === 'place' && isEditingOrCreating) {
                                updateSearchCenterMarker(geographicCenter);
                                // Removed updateSearchRadiusVisual call
                            }
                        }
                    } catch (error) {
                        console.error('Error tracking map center:', error);
                    }
                }, 300));
            }


            // Helper function to clean up map tracking
            function cleanupMapTracking() {
                if (mapViewInstance?.centerWatchHandle) {
                    mapViewInstance.centerWatchHandle.remove();
                    mapViewInstance.centerWatchHandle = null;
                }
            }

            // Add this to your initialization
            function initializeMapEvents() {
                if (!mapViewInstance) {
                    console.error('Map view not initialized');
                    return;
                }

                console.log('Initializing map events');

                // Clean up existing event handlers
                cleanupMapEvents();
                cleanupMapTracking();

                // Initialize center tracking
                updateMapCenterTracking();

                // Watch for extent changes with throttling
                let extentTimeout = null;
                mapViewInstance.watch('extent', () => {
                    if (extentTimeout) {
                        clearTimeout(extentTimeout);
                    }
                    extentTimeout = setTimeout(() => {
                        if (!isEditingOrCreating) {
                            updateOverlay(true);
                        }
                    }, 300);
                });

                // Initialize map click handlers
                initializeMapClickHandlers();

                // Initialize layers
                initializeLayers();

                console.log('Map events initialized');
            }

            // Execute the places search request
            async function executePlacesSearch(url) {
                console.log('Executing places search:', url);
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Places API Response:', errorText);
                    throw new Error(`Places search failed: ${response.statusText}`);
                }

                return await response.json();
            }

            // Process places results into the location format
            function processPlacesResults(results) {
                return results.map(place => ({
                    id: place.placeId || `${place.location.x},${place.location.y}`,
                    name: formatPlaceName(place),
                    type: 'place',
                    location: place.location,
                    placeData: place
                })).filter(place => !selectedLocations.some(selected => selected.id === place.id));
            }

            // Helper function to format place name for display
            function formatPlaceName(placeAttributes) {
                const name = placeAttributes.NAME;
                const state = placeAttributes.STATE_NAME;
                const population = placeAttributes.POP100;
                const lsad = getLSADLabel(placeAttributes.LSAD);
                
                const popInfo = population ? ` (Pop: ${population.toLocaleString()})` : '';
                
                return `${name}, ${state} - ${lsad}${popInfo}`;
            }


            // Update location lists with better place information
            function updateLocationListsWithPlaces() {
                const availableContainer = document.getElementById('availableLocations');
                const selectedContainer = document.getElementById('selectedLocations');

                if (availableContainer && selectedContainer) {
                    // Update available locations with place-specific formatting
                    availableContainer.innerHTML = availableLocations.map(location => {
                        let displayName = location.name;
                        if (location.type === 'place') {
                            displayName = formatPlaceName(location);
                        }
                        return `
                            <div class="location-item" data-id="${location.id}">
                                <label style="display: flex; align-items: center; width: 100%;">
                                    <input type="checkbox" class="location-checkbox" style="margin-right: 8px;">
                                    <div style="flex: 1;">${displayName}</div>
                                </label>
                            </div>
                        `;
                    }).join('');

                    // Update selected locations with place-specific formatting
                    selectedContainer.innerHTML = selectedLocations.map(location => {
                        let displayName = location.name;
                        if (location.type === 'place') {
                            displayName = formatPlaceName(location);
                        }
                        return `
                            <div class="location-item" data-id="${location.id}">
                                <label style="display: flex; align-items: center; width: 100%;">
                                    <input type="checkbox" class="location-checkbox" style="margin-right: 8px;">
                                    <div style="flex: 1;">${displayName}</div>
                                </label>
                            </div>
                        `;
                    }).join('');

                    // Update selected count
                    const selectedCount = document.getElementById('selectedLocationsCount');
                    if (selectedCount) {
                        selectedCount.textContent = `(${selectedLocations.length} selected)`;
                    }
                }
            }            

            let isUpdating = false;  // Add this flag at the global scope

            // Update layers initialization if needed
            function initializeLayers() {
                require(["esri/layers/GraphicsLayer"], function(GraphicsLayer) {
                    // Clear existing layers if they exist
                    if (mapViewInstance && mapViewInstance.map) {
                        if (layers.highlightLayer) {
                            mapViewInstance.map.remove(layers.highlightLayer);
                        }
                    }

                    // Create new layer with specific ID
                    layers.highlightLayer = new GraphicsLayer({
                        id: "highlightLayer",
                        title: "Interactive Overlay",
                        listMode: "hide"
                    });

                    // Add layer to map
                    if (mapViewInstance && mapViewInstance.map) {
                        mapViewInstance.map.add(layers.highlightLayer);
                    }
                });
            }

            async function updateOverlay(skipZoom = false, specificType = null) {
                if (!isEditingOrCreating && !mapViewInstance) {
                    console.log('[updateOverlay] Not in edit/create mode and no map instance, skipping overlay update');
                    return;
                }

                if (isUpdating) {
                    console.log('UPDATE OVERLAY[updateOverlay] Update already in progress, skipping...');
                    return;
                }

                try {
                    isUpdating = true;
                    
                    if (!mapViewInstance || !mapViewInstance.extent) {
                        console.error('[updateOverlay] Missing mapViewInstance or extent');
                        return;
                    }

                    const extent = mapViewInstance.extent;
                    const maType = specificType || document.getElementById('maType')?.value || '';
                    
                    // Clear existing graphics if we're editing/creating
                    if (isEditingOrCreating && layers.highlightLayer) {
                        layers.highlightLayer.removeAll();
                    }

                    // Only proceed with feature query if editing/creating
                    if (isEditingOrCreating) {
                        const features = await queryFeatures(extent, maType);
                        console.log('[updateOverlay] Retrieved features:', features);
                        
                        require([
                            "esri/Graphic",
                            "esri/geometry/Polygon"
                        ], function(Graphic, Polygon) {
                            if (features.length > 0 && layers.highlightLayer) {
                                features.forEach(feature => {
                                    // Determine if the feature is selected based on the MA type
                                    let isSelected = false;
                                    let featureId;
                                    let featureName;

                                    switch(maType) {
                                        case 'block':
                                            featureId = feature.attributes.GEOID;
                                            featureName = `Block ${feature.attributes.BLOCK}, Tract ${feature.attributes.TRACT}`;
                                            isSelected = selectedLocations.some(loc => 
                                                loc.id === featureId || 
                                                loc.geoid === featureId
                                            );
                                            console.log('[updateOverlay] Processing block:', {
                                                featureId,
                                                featureName,
                                                isSelected
                                            });
                                            break;

                                        case 'blockgroup':
                                            featureId = feature.attributes.GEOID;
                                            featureName = `Block Group ${feature.attributes.BLKGRP}, Tract ${feature.attributes.TRACT}`;
                                            isSelected = selectedLocations.some(loc => 
                                                loc.id === featureId || 
                                                loc.geoid === featureId
                                            );
                                            console.log('[updateOverlay] Processing block group:', {
                                                featureId,
                                                featureName,
                                                isSelected
                                            });
                                            break;

                                        case 'place':
                                            featureId = feature.attributes.GEOID;
                                            featureName = `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`;
                                            isSelected = selectedLocations.some(loc => 
                                                loc.id === featureId || 
                                                loc.geoid === featureId ||
                                                loc.placeId === feature.attributes.PLACEFP
                                            );
                                            break;

                                        case 'tract':
                                            featureId = feature.attributes.GEOID;
                                            featureName = `Census Tract ${feature.attributes.TRACTCE20}`;
                                            isSelected = selectedLocations.some(loc => 
                                                loc.id === featureId || 
                                                loc.geoid === featureId
                                            );
                                            break;

                                        case 'zip':
                                            featureId = feature.attributes.ZIP;
                                            featureName = feature.attributes.ZIP;
                                            isSelected = selectedLocations.some(loc => loc.id === featureId);
                                            break;

                                        default:
                                            featureId = `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`;
                                            featureName = featureId;
                                            isSelected = selectedLocations.some(loc => loc.id === featureId);
                                    }

                                    console.log(`[updateOverlay] Feature ${featureId} selected status:`, isSelected);

                                    // Create graphic with appropriate styling
                                    const graphic = new Graphic({
                                        geometry: feature.geometry,
                                        symbol: {
                                            type: "simple-fill",
                                            color: isSelected ? [0, 255, 0, 0.3] : [200, 200, 200, 0.1],
                                            outline: {
                                                color: isSelected ? [0, 255, 0, 1] : [128, 128, 128, 0.5],
                                                width: isSelected ? 2 : 1
                                            }
                                        },
                                        attributes: {
                                            id: featureId,
                                            name: featureName,
                                            type: maType,
                                            geoid: feature.attributes.GEOID,
                                            block: feature.attributes.BLOCK,
                                            blockgroup: feature.attributes.BLKGRP,
                                            tract: feature.attributes.TRACT,
                                            county: feature.attributes.COUNTY,
                                            state: feature.attributes.STATE,
                                            statefp: feature.attributes.STATEFP,
                                            countyfp: feature.attributes.COUNTYFP,
                                            pop100: feature.attributes.POP100,
                                            isSelected: isSelected
                                        }
                                    });

                                    layers.highlightLayer.add(graphic);
                                });
                            }

                            // Handle zoom if needed
                            if (!skipZoom && layers.highlightLayer && layers.highlightLayer.graphics.length > 0) {
                                mapViewInstance.goTo(layers.highlightLayer.graphics.toArray());
                            }
                        });
                    }
                } catch (error) {
                    console.error("[updateOverlay] Error:", error);
                } finally {
                    isUpdating = false;
                }
            }

            async function findMatchingMarketAreas(point) {
                const zipUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_ZIP_Codes/FeatureServer/0";
                const countyUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties/FeatureServer/0";

                return new Promise((resolve, reject) => {
                    require([
                        "esri/rest/support/Query",
                        "esri/rest/query",
                        "esri/geometry/geometryEngine"
                    ], function(Query, query, geometryEngine) {
                        const queryParams = new Query({
                            geometry: point,
                            geometryType: "esriGeometryPoint",
                            spatialRel: "esriSpatialRelIntersects",
                            outFields: ["*"],
                            returnGeometry: true
                        });

                        // Create array to store promises
                        const queryPromises = [
                            query.executeQueryJSON(zipUrl, queryParams),
                            query.executeQueryJSON(countyUrl, queryParams)
                        ];

                        Promise.all(queryPromises)
                            .then(([zipResults, countyResults]) => {
                                const matchingAreas = [];

                                // Process zip results
                                if (zipResults.features && zipResults.features.length > 0) {
                                    const zipCodes = zipResults.features.map(f => f.attributes.ZIP);
                                    const matchingZipMAs = marketAreas.filter(ma => 
                                        ma.type === 'zip' && 
                                        ma.areas.some(area => zipCodes.includes(area.code))
                                    );

                                    matchingZipMAs.forEach(ma => {
                                        const feature = zipResults.features.find(f => 
                                            ma.areas.some(area => area.code === f.attributes.ZIP)
                                        );
                                        if (feature) {
                                            matchingAreas.push({
                                                id: ma.id,
                                                area: geometryEngine.planarArea(feature.geometry),
                                                geometry: feature.geometry,
                                                type: 'zip'
                                            });
                                        }
                                    });
                                }

                                // Process county results
                                if (countyResults.features && countyResults.features.length > 0) {
                                    countyResults.features.forEach(feature => {
                                        const countyName = `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`;
                                        const matchingCountyMAs = marketAreas.filter(ma =>
                                            ma.type === 'county' &&
                                            ma.areas.some(area => area.fullName === countyName)
                                        );

                                        matchingCountyMAs.forEach(ma => {
                                            matchingAreas.push({
                                                id: ma.id,
                                                area: geometryEngine.planarArea(feature.geometry),
                                                geometry: feature.geometry,
                                                type: 'county'
                                            });
                                        });
                                    });
                                }

                                // Sort by area (smallest first)
                                const sortedAreas = matchingAreas.sort((a, b) => a.area - b.area);
                                resolve(sortedAreas);
                            })
                            .catch(error => {
                                console.error("Error in findMatchingMarketAreas:", error);
                                resolve([]); // Resolve with empty array on error
                            });
                    });
                });
            }

            // Helper function to determine if a point is within a polygon
            function isPointInPolygon(point, polygon) {
                require(["esri/geometry/geometryEngine"], function(geometryEngine) {
                    return geometryEngine.contains(polygon, point);
                });
            }

            // Modified initializeMap function with proper async/await handling
            async function initializeMap(isFirstLoad) {
                try {
                    await loadArcGISAPI();
                    
                    return new Promise((resolve, reject) => {
                        require([
                            "esri/Map",
                            "esri/views/MapView",
                            "esri/layers/GraphicsLayer",
                            "esri/widgets/ScaleBar"
                        ], function(Map, MapView, GraphicsLayer, ScaleBar) {
                            const map = new Map({
                                basemap: "streets-navigation-vector"
                            });

                            layers.boundaryLayer = new GraphicsLayer({ id: "boundaryLayer" });
                            layers.labelLayer = new GraphicsLayer({ id: "labelLayer" });
                            layers.highlightLayer = new GraphicsLayer({ id: "highlightLayer" });

                            map.addMany([layers.boundaryLayer, layers.labelLayer, layers.highlightLayer]);

                            mapViewInstance = new MapView({
                                container: "mapDiv",
                                map: map,
                                zoom: 10,
                                spatialReference: { wkid: 102100 }
                            });

                            // Get user's location if available, otherwise use a default center
                            if (navigator.geolocation) {
                                navigator.geolocation.getCurrentPosition(
                                    (position) => {
                                        mapViewInstance.center = [position.coords.longitude, position.coords.latitude];
                                    },
                                    () => {
                                        // Fallback to current map center if geolocation fails
                                        if (mapViewInstance.center) {
                                            console.log('Using current map center');
                                        } else {
                                            // Only use LA as last resort
                                            mapViewInstance.center = [-118.2437, 34.0522];
                                        }
                                    }
                                );
                            }

                            const scaleBar = new ScaleBar({
                                view: mapViewInstance,
                                unit: "imperial",
                                style: "line"
                            });
                            mapViewInstance.ui.add(scaleBar, "bottom-right");

                            mapViewInstance.when(() => {
                                console.log("Map and View are ready");
                                initializeMapEvents();
                                updateMapCenterTracking();
                                resolve(mapViewInstance);
                            }).catch(reject);
                        });
                    });
                } catch (error) {
                    console.error("Error in map initialization:", error);
                    throw error;
                }
            }
            function extractExcelCellColor(cell) {
                // If no cell or no fill, return default red
                if (!cell || !cell.fill) return '#FF0000';

                try {
                    // Get the fill color (rgbString is already formatted with # prefix)
                    const fillColor = cell.fill.fgColor.rgb || cell.fill.fgColor.rgbString;
                    
                    if (!fillColor) return '#FF0000';

                    // If color starts with FF (alpha channel), remove it
                    let colorValue = fillColor.toString();
                    if (colorValue.length === 8) {
                        colorValue = colorValue.substring(2);
                    }

                    // Ensure hex format
                    return colorValue.startsWith('#') ? colorValue : `#${colorValue}`;
                } catch (error) {
                    console.error('Error extracting cell color:', error);
                    return '#FF0000'; // Default to red on error
                }
            }

            // Helper function to get full state name (if not already implemented)
            function getStateFullName(abbreviation) {
                if (!abbreviation) return '';
                
                // Check if it's already a full state name
                const stateNames = Object.values(stateMap);
                if (stateNames.includes(abbreviation.trim())) {
                    return abbreviation.trim();
                }

                const stateMap = {
                    'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas',
                    'CA': 'California', 'CO': 'Colorado', 'CT': 'Connecticut', 'DE': 'Delaware',
                    'FL': 'Florida', 'GA': 'Georgia', 'HI': 'Hawaii', 'ID': 'Idaho',
                    'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa', 'KS': 'Kansas',
                    'KY': 'Kentucky', 'LA': 'Louisiana', 'ME': 'Maine', 'MD': 'Maryland',
                    'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi',
                    'MO': 'Missouri', 'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada',
                    'NH': 'New Hampshire', 'NJ': 'New Jersey', 'NM': 'New Mexico', 'NY': 'New York',
                    'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio', 'OK': 'Oklahoma',
                    'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina',
                    'SD': 'South Dakota', 'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah',
                    'VT': 'Vermont', 'VA': 'Virginia', 'WA': 'Washington', 'WV': 'West Virginia',
                    'WI': 'Wisconsin', 'WY': 'Wyoming', 'DC': 'District of Columbia'
                };

                const abbr = abbreviation.toString().trim().toUpperCase();
                return stateMap[abbr] || abbreviation;
            }



            // Replace the existing performEnrichment function
            async function performEnrichment(studyAreas, variables) {
                try {
                    const response = await fetch('/enrich-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            study_areas: studyAreas,
                            variables: variables
                        })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'Enrichment failed');
                    }

                    const result = await response.json();
                    if (!result.success) {
                        throw new Error(result.error || 'Unknown error');
                    }

                    return result.data;
                } catch (error) {
                    console.error('Enrichment error:', error);
                    throw error;
                }
            }
            // Update the saveAndExitMA function for census tract support
            function formatStudyArea(ma) {
                if (ma.type === 'zip') {
                    return {
                        name: ma.name,
                        type: ma.type,
                        areas: ma.areas.map(a => ({ code: a.code }))
                    };
                } else if (ma.type === 'tract') {
                    return {
                        name: ma.name,
                        type: ma.type,
                        areas: ma.areas.map(a => ({
                            code: a.geoid,
                            name: a.tractId,
                            state: a.stateId,
                            county: a.countyId,
                            vintage: "2020"
                        }))
                    };
                } else {
                    // County handling
                    return {
                        name: ma.name,
                        type: ma.type,
                        areas: ma.areas.map(a => ({
                            name: a.name,
                            state: a.state || getStateFromFullName(a.fullName),
                            fullName: a.fullName,
                            fipsCode: a.fipsCode
                        })).filter(a => a.fipsCode)
                    };
                }
            }



            let currentProjectId;

            let maps = ['Map 1'];
            let currentMap = 'Map 1';
            let marketAreas = [];
            let currentColorIndex = 0;
            let mapViewInstance = null; // To store the MapView instance
            let currentColorTarget = null;
            let colorPalettes = [
                {
                    name: "Standard TCG Colors",
                    colors: ['#FF0000', '#0000FF', '#00FF00', '#FFA500', '#FFFF00', '#800080']
                }
            ];
            let recentColors = [];
        

            document.addEventListener('DOMContentLoaded', async function() {
                try {
                    console.log('DOM content loaded');
                    
                    // Get project ID
                    currentProjectId = getCurrentProjectId();
                    console.log('Current Project ID:', currentProjectId);

                    // Initialize map first
                    await initializeMap(true);
                    arcgisLoaded = true;
                    
                    // Initialize page and load market areas
                    await initializePage();
                    await loadSavedMarketAreas();
                    console.log('Page initialized');

                    // Setup transparency controls
                    const transparencyRange = document.getElementById('transparency');
                    const transparencyValue = document.getElementById('transparencyValue');
                    
                    if (transparencyRange && transparencyValue) {
                        transparencyRange.addEventListener('input', function() {
                            transparencyValue.value = this.value;
                        });
                        
                        transparencyValue.addEventListener('input', function() {
                            transparencyRange.value = this.value;
                        });
                    } else {
                        console.error('Transparency inputs not found');
                    }

                    // Setup color controls
                    const fillColorInput = document.getElementById('fillColor');
                    const borderColorInput = document.getElementById('borderColor');
                    const fillColorDisplay = document.getElementById('fillColorDisplay');
                    const borderColorDisplay = document.getElementById('borderColorDisplay');

                    if (fillColorInput && borderColorInput && fillColorDisplay && borderColorDisplay) {
                        fillColorInput.addEventListener('input', function() {
                            fillColorDisplay.style.backgroundColor = this.value;
                        });

                        borderColorInput.addEventListener('input', function() {
                            borderColorDisplay.style.backgroundColor = this.value;
                        });

                        fillColorDisplay.style.backgroundColor = fillColorInput.value;
                        borderColorDisplay.style.backgroundColor = borderColorInput.value;
                    } else {
                        console.error('Color inputs or displays not found');
                    }

                    // Setup other event listeners
                    document.addEventListener('click', handleOutsideClick);
                    setupColorInputEventListeners();
                    setupSearchFunctionality();

                } catch (error) {
                    console.error('Error during initialization:', error);
                }
            });

            // Update the initializeMapEvents function
            function initializeMapEvents() {
                if (!mapViewInstance) {
                    console.error('Map view not initialized');
                    return;
                }

                console.log('Initializing map events');

                // Clean up existing event handlers
                cleanupMapEvents();

                // Watch for extent changes with throttling
                let extentTimeout = null;
                mapViewInstance.watch('extent', () => {
                    if (extentTimeout) {
                        clearTimeout(extentTimeout);
                    }
                    extentTimeout = setTimeout(() => {
                        if (!isEditingOrCreating) {
                            updateOverlay(true);
                        }
                    }, 300);
                });

                // Initialize map click handlers
                initializeMapClickHandlers();

                // Initialize layers
                initializeLayers();

                console.log('Map events initialized');
            }

            // Update the initializePage function to ensure proper initialization order
            async function initializePage() {
                try {
                    console.log('Initializing page');
                    
                    // Initialize map first
                    await initializeMap(true);
                    
                    // Update tabs and lists after map is ready
                    updateMapTabs();
                    updateMAList();
                    setupSearchFunctionality();
                    setupColorInputEventListeners();
                    loadColorPalettes();
                    loadRecentColors();
                    addTypeChangeHandler();
                    
                    // Get project details and update title
                    const projectNumber = document.querySelector('.project-number')?.textContent || '';
                    const projectClient = document.querySelector('.project-client')?.textContent || '';
                    const projectLocation = document.querySelector('.project-location')?.textContent || '';
                    
                    const projectTitle = document.getElementById('project-title');
                    if (projectTitle) {
                        projectTitle.innerHTML = `
                            <span class="project-number">${projectNumber}</span>
                            <span class="project-separator"> - </span>
                            <span class="project-client">${projectClient}</span>
                            <span class="project-separator"> - </span>
                            <span class="project-location">${projectLocation}</span>
                        `;
                    }

                    console.log('Page initialization complete');
                } catch (error) {
                    console.error("Error initializing page:", error);
                }
            }


            function updateMapTabs() {
                const tabContainer = document.getElementById('map-tabs');
                tabContainer.innerHTML = '';
                maps.forEach((map, index) => {
                    const mapTab = document.createElement('div');
                    mapTab.className = `map-tab ${currentMap === map ? 'active-map-tab' : ''}`;
                    mapTab.textContent = map;
                    mapTab.onclick = () => setCurrentMap(map);
                    tabContainer.appendChild(mapTab);
                });
            }
        
            function setCurrentMap(map) {
                currentMap = map;
                updateMapTabs();
                updateMap();
            }
        
            // Update the showCreateNewMAForm function to remove default selection
            async function showCreateNewMAForm() {
                // Hide list and show form
                document.getElementById('ma-list').style.display = 'none';
                document.getElementById('ma-form').style.display = 'flex';
                
                // Reset form fields with empty type selection
                document.getElementById('maType').value = '';  // Remove default selection
                document.getElementById('maName').value = '';
                document.getElementById('shortName').value = '';
                document.getElementById('acsCheckbox').checked = true;
                
                // Initialize location selector
                initializeLocationSelector();
                
                // Reset arrays
                availableLocations = [];
                selectedLocations = [];
                updateLocationLists();
                
                // Initialize color inputs
                setColor('fill', '#FF0000');
                document.getElementById('transparency').value = 50;
                document.getElementById('transparencyValue').value = 50;
                document.getElementById('borderWeight').value = 1;
                document.getElementById('noBorder').checked = false;
                
                // Update the type-specific fields
                toggleMATypeFields();
                
                // Reset the Save & Exit button
                const saveButton = document.querySelector('#ma-form .green-button');
                if (saveButton) {
                    saveButton.textContent = 'Save & Exit';
                    saveButton.onclick = saveAndExitMA;
                }

                // Remove the Remove MA button if it exists
                const removeButton = document.querySelector('#ma-form .button-row .remove-ma-button');
                if (removeButton) {
                    removeButton.remove();
                }
            }
        
            // Update the initializeMap function to add the type change handler
            function addTypeChangeHandler() {
                const typeSelect = document.getElementById('maType');
                if (typeSelect) {
                    typeSelect.addEventListener('change', async function() {
                        // Clear existing selections
                        availableLocations = [];
                        selectedLocations = [];
                        updateLocationLists();
                        
                        // Update fields and overlay
                        toggleMATypeFields();
                        
                        // If a type is selected, initialize the interactive overlay
                        if (this.value) {
                            await initializeInteractiveOverlay(this.value);
                            await updateOverlay(true, this.value);
                        }
                    });
                }
            }
            function getPlaceholderForType(maType) {
                switch(maType) {
                    case 'zip':
                        return "Search for zip codes...";
                    case 'county':
                        return "Search for counties...";
                    case 'tract':
                        return "Search for census tracts...";
                    case 'place':
                        return "Search for places...";
                    default:
                        return "Search for locations...";
                }
            }


            function toggleMATypeFields() {
                const maType = document.getElementById('maType').value;
                clearHighlightGraphics(); // Clear graphics when type changes
                let locationSearch = document.getElementById('locationSearch');
                let availableLocations = document.getElementById('availableLocations');
                let selectedLocations = document.getElementById('selectedLocations');
                const driveTimeSection = document.getElementById('driveTimeSection');
                const radiusSection = document.getElementById('radiusSection');
                let transferButtons = document.querySelector('.entries-section .button-group');
                
                // Reset all sections first
                [locationSearch, availableLocations, selectedLocations, transferButtons].forEach(el => {
                    if (el) el.style.display = 'block';
                });
                if (driveTimeSection) driveTimeSection.style.display = 'none';
                if (radiusSection) radiusSection.style.display = 'none';

                if (!maType) {
                    if (locationSearch) {
                        locationSearch.placeholder = "Please select a type first...";
                        locationSearch.disabled = true;
                    }
                    if (layers.highlightLayer) {
                        layers.highlightLayer.removeAll();
                    }
                    return;
                }

                switch(maType) {
                    case 'state':
                        locationSearch.placeholder = "Search for states...";
                        break;
                    case 'usa':
                        locationSearch.placeholder = "Select USA boundary";
                        locationSearch.disabled = true; // Disable for USA as there's only one option
                        searchUSA(); // Automatically populate the single USA option
                        break;
                    
                    case 'drivetime':
                        // Show drive time UI, hide regular location selector
                        [locationSearch, availableLocations, selectedLocations, transferButtons].forEach(el => {
                            if (el) el.style.display = 'none';
                        });
                        if (driveTimeSection) {
                            driveTimeSection.style.display = 'block';
                            initializeDriveTimeControls();
                        }
                        break;
                    
                    case 'radius':
                        // Show radius UI, hide regular location selector
                        [locationSearch, availableLocations, selectedLocations, transferButtons].forEach(el => {
                            if (el) el.style.display = 'none';
                        });
                        if (radiusSection) {
                            radiusSection.style.display = 'block';
                            initializeRadiusControls();
                        }
                        break;
                    
                    default:
                        // Set appropriate placeholder for other types
                        if (locationSearch) {
                            locationSearch.disabled = false;
                            locationSearch.placeholder = getPlaceholderForType(maType);
                        }
                        
                        // Clear any existing search results
                        window.availableLocations = [];
                        updateLocationLists();
                        break;
                }
            }

            function createGraphic(feature, ma) {
                if (!feature.geometry) return null;

                const attrs = feature.attributes;
                let displayName = attrs.name;
                
                // Special handling for blocks
                if (attrs.type === 'block') {
                    displayName = `Block ${attrs.BLOCK}, Tract ${attrs.TRACT}`;
                    if (attrs.POP100) {
                        displayName += ` (Pop: ${attrs.POP100.toLocaleString()})`;
                    }
                }

                return new Graphic({
                    geometry: feature.geometry,
                    symbol: {
                        type: "simple-fill",
                        color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                        outline: ma.borderWeight > 0 ? {
                            color: ma.borderColor,
                            width: ma.borderWeight
                        } : null
                    },
                    attributes: {
                        id: attrs.GEOID || attrs.id,
                        name: displayName,
                        type: attrs.type,
                        GEOID: attrs.GEOID,
                        BLOCK: attrs.BLOCK,
                        TRACT: attrs.TRACT,
                        STATE: attrs.STATE,
                        COUNTY: attrs.COUNTY,
                        POP100: attrs.POP100,
                        STATEFP: attrs.STATEFP,
                        COUNTYFP: attrs.COUNTYFP
                    }
                });
            }


            function addZipCodeEntry() {
                const container = document.getElementById('zipCodesContainer');
                const entry = document.createElement('div');
                entry.className = 'zip-code-entry';
                entry.innerHTML = `
                    <input type="text" class="zip-code-input" placeholder="Enter zip code">
                    <button class="remove-entry-button" onclick="removeEntry(this)">&#10006;</button>
                `;
                container.appendChild(entry);
            }
        
            function addCountyEntry() {
                const container = document.getElementById('countiesContainer');
                const entry = document.createElement('div');
                entry.className = 'county-entry';
                entry.innerHTML = `
                    <input type="text" class="county-input" placeholder="Enter county name">
                    <button class="remove-entry-button" onclick="removeEntry(this)">&#10006;</button>
                    <div class="county-suggestions"></div>
                `;
                container.appendChild(entry);
        
                const countyInput = entry.querySelector('.county-input');
                const suggestionsContainer = entry.querySelector('.county-suggestions');
        
                let debounceTimer;
                countyInput.addEventListener('input', function() {
                    const query = this.value;
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => {
                        if (query.length >= 3) {
                            fetchCountySuggestions(query, suggestionsContainer);
                        } else {
                            suggestionsContainer.innerHTML = '';
                            suggestionsContainer.style.display = 'none';
                        }
                    }, 300); // Debounce for 300ms
                });
        
                countyInput.addEventListener('blur', function() {
                    setTimeout(() => {
                        suggestionsContainer.innerHTML = '';
                        suggestionsContainer.style.display = 'none';
                    }, 200);
                });
            }
        
            function removeEntry(button) {
                const entry = button.parentElement;
                entry.remove();
            }
        
            function fetchCountySuggestions(query, suggestionsContainer) {
                require(["esri/request"], function(esriRequest) {
                    const url = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Counties/FeatureServer/0/query";
                    const params = {
                        where: `NAME LIKE '%${query}%'`,
                        outFields: "NAME,STATE_NAME",
                        returnGeometry: false,
                        returnDistinctValues: true,
                        orderByFields: "NAME",
                        f: "json"
                    };
        
                    esriRequest(url, {
                        query: params
                    }).then(function(response) {
                        const counties = response.data.features.map(feature => 
                            `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`
                        );
                        displayCountySuggestions(counties, suggestionsContainer);
                    }).catch(function(error) {
                        console.error("Error fetching county suggestions:", error);
                    });
                });
            }
        
            function displayCountySuggestions(suggestions, suggestionsContainer) {
                suggestionsContainer.innerHTML = '';
                
                if (suggestions.length === 0) {
                    suggestionsContainer.style.display = 'none';
                    return;
                }
        
                const ul = document.createElement('ul');
                ul.className = 'county-suggestion-list';
                ul.style.listStyle = 'none';
                ul.style.padding = '0';
                ul.style.margin = '0';
        
                suggestions.forEach(county => {
                    const li = document.createElement('li');
                    li.textContent = county;
                    li.style.padding = '8px 12px';
                    li.style.cursor = 'pointer';
                    li.style.borderBottom = '1px solid #eee';
                    li.addEventListener('mouseover', () => {
                        li.style.backgroundColor = '#f0f0f0';
                    });
                    li.addEventListener('mouseout', () => {
                        li.style.backgroundColor = 'white';
                    });
                    li.addEventListener('click', function() {
                        const countyInput = this.closest('.county-entry').querySelector('.county-input');
                        countyInput.value = county;
                        countyInput.dataset.fullName = county;
                        suggestionsContainer.innerHTML = '';
                        suggestionsContainer.style.display = 'none';
                    });
                    ul.appendChild(li);
                });
        
                suggestionsContainer.appendChild(ul);
                suggestionsContainer.style.display = 'block';
            }
        
            function removeMA(id) {
                if (confirm('Are you sure you want to remove this Market Area?')) {
                    marketAreas = marketAreas.filter(ma => ma.id !== id);
                    updateMAList();
                    updateMap();
                    cancelCreateMA();
                }
            }
        
            // Update the searchCBSA function to search across all CBSA types
            function searchCBSA(query) {
                const cbsaLayers = {
                    metro: "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/CBSA/MapServer/3",
                    micro: "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/CBSA/MapServer/4",
                    division: "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/CBSA/MapServer/2"
                };

                const params = {
                    f: 'json',
                    where: `UPPER(NAME) LIKE UPPER('%${query}%')`,
                    outFields: "CBSAFP,NAME,MEMI,GEOID,BASENAME,CSA",
                    returnDistinctValues: true,
                    returnGeometry: false,
                    orderByFields: "NAME",
                };

                const searchPromises = Object.entries(cbsaLayers).map(async ([type, url]) => {
                    try {
                        const response = await fetch(`${url}/query?${new URLSearchParams(params)}`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        
                        if (data.features) {
                            return data.features.map(feature => ({
                                id: feature.attributes.CBSAFP || feature.attributes.GEOID,
                                name: `${feature.attributes.NAME} (${type === 'metro' ? 'Metropolitan' : 
                                    type === 'micro' ? 'Micropolitan' : 'Metro Division'})`,
                                type: 'cbsa',
                                cbsaType: type,
                                cbsaId: feature.attributes.CBSAFP || feature.attributes.GEOID,
                                csaId: feature.attributes.CSA,
                                basename: feature.attributes.BASENAME
                            }));
                        }
                        return [];
                    } catch (error) {
                        console.error(`Error searching ${type} CBSAs:`, error);
                        return [];
                    }
                });

                Promise.all(searchPromises)
                    .then(results => {
                        const allResults = results.flat();
                        availableLocations = allResults.filter(cbsa => 
                            !selectedLocations.some(selected => selected.id === cbsa.id)
                        );
                        updateLocationLists();
                    })
                    .catch(error => {
                        console.error('Error in CBSA search:', error);
                        availableLocations = [];
                        updateLocationLists();
                    });
            }


            function saveAndExitMA() {
                const maType = document.getElementById('maType').value;
                const name = document.getElementById('maName').value;
                const shortName = document.getElementById('shortName').value;
                const acs = document.getElementById('acsCheckbox').checked;

                console.log('[saveAndExitMA] Starting save with:', {
                    maType,
                    name,
                    selectedLocations
                });

                if (!name.trim()) {
                    alert('Please enter a Market Area name');
                    return;
                }

                if (selectedLocations.length === 0) {
                    const typeLabel = {
                        'zip': 'zip code',
                        'county': 'county',
                        'tract': 'census tract',
                        'block': 'census block',
                        'blockgroup': 'block group',
                        'place': 'place',
                        'drivetime': 'drive time area',
                        'radius': 'radius area',
                        'cbsa': 'CBSA',
                        'state': 'state',
                        'usa': 'USA boundary'
                    }[maType];
                    alert(`Please select at least one ${typeLabel}`);
                    return;
                }

                let areas;
                switch (maType) {
                    case 'blockgroup':
                        console.log('[saveAndExitMA] Processing block groups:', selectedLocations);
                        areas = selectedLocations.map(location => {
                            // Ensure we have all necessary data
                            const fullData = {
                                geoid: location.id || location.geoid || location.GEOID,
                                blockGroupId: location.blockGroupId || location.BLKGRP,
                                tractId: location.tractId || location.TRACT,
                                stateId: location.stateId || location.STATEFP,
                                countyId: location.countyId || location.COUNTYFP,
                                population: location.population || location.POP100,
                                // Include all original attributes
                                GEOID: location.id || location.geoid || location.GEOID,
                                BLKGRP: location.blockGroupId || location.BLKGRP,
                                TRACT: location.tractId || location.TRACT,
                                STATEFP: location.stateId || location.STATEFP,
                                COUNTYFP: location.countyId || location.COUNTYFP,
                                POP100: location.population || location.POP100,
                                name: `Block Group ${location.blockGroupId || location.BLKGRP}, Tract ${location.tractId || location.TRACT}`,
                                attributes: {
                                    ...location.attributes,
                                    type: 'blockgroup'
                                }
                            };

                            console.log('[saveAndExitMA] Processed block group data:', fullData);
                            return fullData;
                        });
                        console.log('[saveAndExitMA] Processed block groups:', areas);
                        break;

                    case 'block':
                        areas = selectedLocations.map(location => ({
                            geoid: location.geoid || location.GEOID || location.id,
                            blockId: location.blockId || location.BLOCK,
                            tractId: location.tractId || location.TRACT,
                            stateId: location.stateId || location.STATEFP,
                            countyId: location.countyId || location.COUNTYFP,
                            name: `Block ${location.blockId || location.BLOCK}, Tract ${location.tractId || location.TRACT}`,
                            population: location.population || location.POP100,
                            // Keep all original identifiers
                            BLOCK: location.BLOCK || location.blockId,
                            TRACT: location.TRACT || location.tractId,
                            GEOID: location.GEOID || location.geoid,
                            STATEFP: location.STATEFP || location.stateId,
                            COUNTYFP: location.COUNTYFP || location.countyId,
                            POP100: location.POP100 || location.population,
                            attributes: {
                                ...location.attributes,
                                type: 'block'
                            }
                        }));
                        break;

                    case 'tract':
                        areas = selectedLocations.map(location => ({
                            geoid: location.geoid || location.GEOID,
                            tractId: location.tractId || location.TRACT,
                            stateId: location.stateId || location.STATEFP,
                            countyId: location.countyId || location.COUNTYFP,
                            name: `Census Tract ${location.tractId || location.TRACT}`,
                            GEOID: location.GEOID || location.geoid,
                            TRACT: location.TRACT || location.tractId,
                            STATEFP: location.STATEFP || location.stateId,
                            COUNTYFP: location.COUNTYFP || location.countyId,
                            attributes: {
                                ...location.attributes,
                                type: 'tract'
                            }
                        }));
                        break;

                    case 'drivetime':
                        areas = selectedLocations.map(location => ({
                            centerPoint: location.centerPoint,
                            minutes: location.minutes,
                            geometry: location.geometry,
                            name: `${location.minutes} Minute Drive Time`,
                            attributes: {
                                ...location.attributes,
                                type: 'drivetime'
                            }
                        }));
                        break;

                    case 'radius':
                        areas = selectedLocations.map(location => ({
                            centerPoint: location.centerPoint,
                            radiusValues: location.radiusValues,
                            geometries: location.geometries,
                            name: `Radius Areas (${location.radiusValues.join(', ')} miles)`,
                            attributes: {
                                ...location.attributes,
                                type: 'radius'
                            }
                        }));
                        break;

                    case 'zip':
                        areas = selectedLocations.map(location => ({
                            code: location.id || location.ZIP,
                            attributes: {
                                ...location.attributes,
                                type: 'zip'
                            }
                        }));
                        break;

                    case 'county':
                        areas = selectedLocations.map(location => {
                            const [countyName, stateName] = (location.name || location.fullName).split(',').map(part => part.trim());
                            return {
                                name: countyName.replace(/\s+County$/, ''),
                                fullName: `${countyName}, ${stateName}`,
                                state: stateName,
                                fipsCode: location.fipsCode,
                                attributes: {
                                    ...location.attributes,
                                    type: 'county'
                                }
                            };
                        });
                        break;

                    case 'place':
                        areas = selectedLocations.map(location => ({
                            placeId: location.placeId,
                            name: location.name,
                            location: location.location,
                            address: location.placeData?.address || {},
                            formattedAddress: location.placeData?.formattedAddress || '',
                            PLACEFP: location.placeId,
                            GEOID: location.geoid || location.GEOID,
                            attributes: {
                                ...location.attributes,
                                type: 'place'
                            }
                        }));
                        break;

                    case 'cbsa':
                        areas = selectedLocations.map(location => ({
                            cbsaId: location.cbsaId,
                            name: location.name,
                            cbsaType: location.cbsaType,
                            csaId: location.csaId,
                            basename: location.basename,
                            attributes: {
                                ...location.attributes,
                                type: 'cbsa'
                            }
                        }));
                        break;

                    case 'state':
                        areas = selectedLocations.map(location => ({
                            name: location.name,
                            stateAbbr: location.stateAbbr,
                            fips: location.fips,
                            attributes: {
                                ...location.attributes,
                                type: 'state'
                            }
                        }));
                        break;

                    default:
                        console.warn('[saveAndExitMA] Unhandled market area type:', maType);
                        return;
                }

                const maData = {
                    type: maType,
                    name: name,
                    shortName: shortName,
                    acs: acs,
                    areas: areas,
                    fillColor: document.getElementById('fillColor').value,
                    borderColor: document.getElementById('borderColor').value,
                    transparency: parseInt(document.getElementById('transparency').value),
                    borderWeight: document.getElementById('noBorder').checked ? 0 : parseInt(document.getElementById('borderWeight').value),
                    visible: true
                };

                console.log('[saveAndExitMA] Final MA data:', maData);

                // Add or update market area
                const saveButton = document.querySelector('#ma-form .green-button');
                if (saveButton.textContent === 'Update MA') {
                    const maId = parseInt(saveButton.getAttribute('data-ma-id'));
                    updateExistingMA(maId, maData);
                } else {
                    addNewMA(maData);
                }

                // Reset state and cleanup
                isEditingOrCreating = false;
                if (layers.highlightLayer) {
                    layers.highlightLayer.removeAll();
                }

                // Reset location arrays and hide form
                availableLocations = [];
                selectedLocations = [];
                document.getElementById('ma-form').style.display = 'none';
                document.getElementById('ma-list').style.display = 'block';

                // Reinitialize map click handlers and update display
                reinitializeMapClickHandlers();
                updateMap();
            }


            function initializeRadiusControls() {
                console.log('Initializing radius controls');
                const pinButton = document.getElementById('radiusPinButton');
                const pinInstructions = document.getElementById('radiusPinInstructions');
                const addRadiusButton = document.getElementById('addRadiusButton');
                
                // Reset state
                isRadiusPinMode = false;
                if (radiusMapClickHandler) {
                    radiusMapClickHandler.remove();
                    radiusMapClickHandler = null;
                }
                
                // Initialize pin button click handler
                pinButton.onclick = toggleRadiusPinMode;
                
                // Initialize add radius button
                addRadiusButton.onclick = addNewRadius;
                
                function toggleRadiusPinMode() {
                    isRadiusPinMode = !isRadiusPinMode;
                    
                    // Update UI
                    pinButton.innerHTML = isRadiusPinMode ? 
                        '<span class="pin-icon">📍</span> Cancel Pin' : 
                        '<span class="pin-icon">📍</span> Place Pin';
                    pinButton.classList.toggle('active', isRadiusPinMode);
                    pinInstructions.style.display = isRadiusPinMode ? 'block' : 'none';
                    
                    // Handle map clicks
                    if (isRadiusPinMode) {
                        radiusMapClickHandler = mapViewInstance.on("click", handleRadiusMapClick);
                    } else if (radiusMapClickHandler) {
                        radiusMapClickHandler.remove();
                        radiusMapClickHandler = null;
                    }
                }

                // Reset the radius list to initial state if empty
                const radiusList = document.getElementById('radiusList');
                if (radiusList.children.length === 0) {
                    addNewRadius();
                }
            }

            function updateExistingMA(id, maData) {
                console.log('[updateExistingMA] Starting update with:', { id, maData });
                
                if (!id || !maData) {
                    console.error('[updateExistingMA] Missing required parameters:', { id, maData });
                    return;
                }

                const ma = marketAreas.find(ma => ma.id === id);
                if (!ma) {
                    console.error('[updateExistingMA] Market area not found:', id);
                    return;
                }

                // Process the areas based on type before updating
                let processedAreas;
                switch (maData.type) {
                    case 'blockgroup':
                        processedAreas = maData.areas.map(area => ({
                            id: area.id || area.geoid || area.GEOID,
                            geoid: area.id || area.geoid || area.GEOID,
                            blockGroupId: area.blockGroupId || area.BLKGRP,
                            tractId: area.tractId || area.TRACT,
                            stateId: area.stateId || area.STATEFP,
                            countyId: area.countyId || area.COUNTYFP,
                            population: area.population || area.POP100,
                            // Include all Census identifiers
                            GEOID: area.id || area.geoid || area.GEOID,
                            BLKGRP: area.blockGroupId || area.BLKGRP,
                            TRACT: area.tractId || area.TRACT,
                            STATEFP: area.stateId || area.STATEFP,
                            COUNTYFP: area.countyId || area.COUNTYFP,
                            POP100: area.population || area.POP100,
                            name: `Block Group ${area.blockGroupId || area.BLKGRP}, Tract ${area.tractId || area.TRACT}`,
                            type: 'blockgroup',
                            attributes: {
                                ...area.attributes,
                                type: 'blockgroup'
                            }
                        }));
                        break;

                    case 'block':
                        processedAreas = maData.areas.map(area => ({
                            id: area.id || area.geoid || area.GEOID,
                            geoid: area.id || area.geoid || area.GEOID,
                            blockId: area.blockId || area.BLOCK,
                            tractId: area.tractId || area.TRACT,
                            stateId: area.stateId || area.STATEFP,
                            countyId: area.countyId || area.COUNTYFP,
                            population: area.population || area.POP100,
                            GEOID: area.id || area.geoid || area.GEOID,
                            BLOCK: area.blockId || area.BLOCK,
                            TRACT: area.tractId || area.TRACT,
                            STATEFP: area.stateId || area.STATEFP,
                            COUNTYFP: area.countyId || area.COUNTYFP,
                            POP100: area.population || area.POP100,
                            name: `Block ${area.blockId || area.BLOCK}, Tract ${area.tractId || area.TRACT}`,
                            type: 'block',
                            attributes: {
                                ...area.attributes,
                                type: 'block'
                            }
                        }));
                        break;

                    case 'zip':
                        processedAreas = maData.areas.map(area => ({
                            id: area.id || area.code,
                            code: area.code,
                            type: 'zip',
                            attributes: {
                                ...area.attributes,
                                type: 'zip'
                            }
                        }));
                        break;

                    case 'county':
                        processedAreas = maData.areas.map(area => {
                            const [countyName, stateName] = (area.fullName || area.name).split(',').map(part => part.trim());
                            return {
                                id: area.id || `${countyName}, ${stateName}`,
                                name: countyName.replace(/\s+County$/, ''),
                                fullName: area.fullName || `${countyName}, ${stateName}`,
                                state: stateName,
                                fipsCode: area.fipsCode,
                                type: 'county',
                                attributes: {
                                    ...area.attributes,
                                    type: 'county'
                                }
                            };
                        });
                        break;

                    case 'tract':
                        processedAreas = maData.areas.map(area => ({
                            id: area.id || area.geoid || area.GEOID,
                            geoid: area.id || area.geoid || area.GEOID,
                            tractId: area.tractId || area.TRACT,
                            stateId: area.stateId || area.STATEFP,
                            countyId: area.countyId || area.COUNTYFP,
                            name: `Census Tract ${area.tractId || area.TRACT}`,
                            GEOID: area.id || area.geoid || area.GEOID,
                            TRACT: area.tractId || area.TRACT,
                            STATEFP: area.stateId || area.STATEFP,
                            COUNTYFP: area.countyId || area.COUNTYFP,
                            type: 'tract',
                            attributes: {
                                ...area.attributes,
                                type: 'tract'
                            }
                        }));
                        break;

                    case 'place':
                        processedAreas = maData.areas.map(area => ({
                            id: area.id || area.placeId,
                            placeId: area.placeId,
                            name: area.name,
                            location: area.location,
                            address: area.address,
                            formattedAddress: area.formattedAddress,
                            PLACEFP: area.placeId,
                            GEOID: area.GEOID,
                            type: 'place',
                            attributes: {
                                ...area.attributes,
                                type: 'place'
                            }
                        }));
                        break;

                    case 'drivetime':
                        processedAreas = maData.areas.map(area => ({
                            id: area.id || `drivetime-${area.centerPoint.x}-${area.centerPoint.y}`,
                            centerPoint: area.centerPoint,
                            minutes: area.minutes,
                            geometry: area.geometry,
                            name: `${area.minutes} Minute Drive Time`,
                            type: 'drivetime',
                            attributes: {
                                ...area.attributes,
                                type: 'drivetime'
                            }
                        }));
                        break;

                    case 'radius':
                        processedAreas = maData.areas.map(area => ({
                            id: area.id || `radius-${area.centerPoint.x}-${area.centerPoint.y}`,
                            centerPoint: area.centerPoint,
                            radiusValues: area.radiusValues,
                            geometries: area.geometries,
                            name: `Radius Areas (${area.radiusValues.join(', ')} miles)`,
                            type: 'radius',
                            attributes: {
                                ...area.attributes,
                                type: 'radius'
                            }
                        }));
                        break;

                    case 'state':
                        processedAreas = maData.areas.map(area => ({
                            id: area.id || area.name,
                            name: area.name,
                            stateAbbr: area.stateAbbr,
                            fips: area.fips,
                            type: 'state',
                            attributes: {
                                ...area.attributes,
                                type: 'state'
                            }
                        }));
                        break;

                    default:
                        processedAreas = maData.areas;
                }

                // Update the market area with processed data
                const updatedMA = {
                    ...ma,
                    name: maData.name,
                    shortName: maData.shortName,
                    acs: maData.acs,
                    areas: processedAreas,
                    fillColor: maData.fillColor,
                    borderColor: maData.borderColor,
                    transparency: maData.transparency,
                    borderWeight: maData.borderWeight,
                    visible: true,
                    type: maData.type
                };

                // Replace the old market area with the updated one
                const index = marketAreas.findIndex(ma => ma.id === id);
                if (index !== -1) {
                    marketAreas[index] = updatedMA;
                    console.log('[updateExistingMA] Updated market area:', updatedMA);
                }

                // Update UI and map
                updateMAList();
                updateMap(id);

                // Reset form display
                document.getElementById('ma-form').style.display = 'none';
                document.getElementById('ma-list').style.display = 'block';

                // Reset editing state
                isEditingOrCreating = false;

                // Clear selection arrays
                availableLocations = [];
                selectedLocations = [];

                // Reinitialize map click handlers
                reinitializeMapClickHandlers();
            }

            // Add this to track event handlers
            let mapClickHandler = null;
            let mapMoveHandler = null;

            // Update the cancelCreateMA function
            function cancelCreateMA() {
                // Reset edit mode flag
                isEditingOrCreating = false;

                // Reset form fields
                document.getElementById('maType').value = 'zip';
                document.getElementById('maName').value = '';
                document.getElementById('shortName').value = '';
                document.getElementById('acsCheckbox').checked = true;
                document.getElementById('transparency').value = 50;
                document.getElementById('transparencyValue').value = 50;
                document.getElementById('borderWeight').value = 1;
                document.getElementById('noBorder').checked = false;
                
                setColor('fill', '#FF0000');
                setColor('border', '#FF0000');
                
                // Clear location arrays
                availableLocations = [];
                selectedLocations = [];
                if (document.getElementById('locationSearch')) {
                    document.getElementById('locationSearch').value = '';
                }
                
                // Clear the highlight layer
                if (layers.highlightLayer) {
                    layers.highlightLayer.removeAll();
                }
                
                // Hide form and show list
                document.getElementById('ma-form').style.display = 'none';
                document.getElementById('ma-list').style.display = 'block';
                
                // Reset save button
                const saveButton = document.querySelector('#ma-form .green-button');
                if (saveButton) {
                    saveButton.textContent = 'Save & Exit';
                    saveButton.onclick = saveAndExitMA;
                }

                // Remove the Remove MA button if it exists
                const removeButton = document.querySelector('#ma-form .button-row .remove-ma-button');
                if (removeButton) {
                    removeButton.remove();
                }

                // Remove and reattach map click handlers
                reinitializeMapClickHandlers();

                // Update the map to show only saved market areas
                updateMap();
            }

            // First, update the map click handlers initialization
            function initializeMapClickHandlers() {
                if (!mapViewInstance) {
                    console.log('Map view not initialized, skipping click handlers');
                    return;
                }

                console.log('Initializing map click handlers');

                // Remove existing handlers
                if (mapClickHandler) {
                    mapClickHandler.remove();
                    mapClickHandler = null;
                }
                if (mapMoveHandler) {
                    mapMoveHandler.remove();
                    mapMoveHandler = null;
                }

                // Add new click handler if not in edit mode
                if (!isEditingOrCreating) {
                    mapClickHandler = mapViewInstance.on("click", async (event) => {
                        try {
                            const screenPoint = {
                                x: event.x,
                                y: event.y
                            };

                            const point = mapViewInstance.toMap(screenPoint);
                            const matchingAreas = await findMatchingMarketAreas(point);

                            if (matchingAreas && matchingAreas.length > 0) {
                                const smallestArea = matchingAreas[0];
                                editMA(smallestArea.id);
                            }
                        } catch (error) {
                            console.error("Error processing map click:", error);
                        }
                    });

                    // Add hover handler
                    mapMoveHandler = mapViewInstance.on("pointer-move", (event) => {
                        const screenPoint = {
                            x: event.x,
                            y: event.y
                        };

                        mapViewInstance.hitTest(screenPoint, { include: [layers.highlightLayer] })
                            .then(response => {
                                const validResults = response.results.filter(result => 
                                    result.graphic && 
                                    result.graphic.attributes &&
                                    result.graphic.layer === layers.highlightLayer
                                );

                                mapViewInstance.container.style.cursor = validResults.length > 0 ? 'pointer' : 'default';
                            });
                    });
                }
            }

            // Then add the reinitializeMapClickHandlers function
            function reinitializeMapClickHandlers() {
                console.log('Reinitializing map click handlers');
                
                // Make sure we have a map instance
                if (!mapViewInstance) {
                    console.log('No map instance available');
                    return;
                }

                // Reset editing state
                isEditingOrCreating = false;

                // Clear existing handlers
                if (mapClickHandler) {
                    mapClickHandler.remove();
                    mapClickHandler = null;
                }
                if (mapMoveHandler) {
                    mapMoveHandler.remove();
                    mapMoveHandler = null;
                }

                // Initialize new handlers
                initializeMapClickHandlers();

                // Update the overlay if needed
                if (mapViewInstance && mapViewInstance.extent) {
                    updateOverlay(true).catch(error => {
                        console.error('Error updating overlay during reinitialization:', error);
                    });
                }
            }



            // Validate zip codes
            function validateZipCodes(areas) {
                const invalidZips = areas.filter(zip => !/^\d{5}$/.test(zip.code));
                if (invalidZips.length > 0) {
                    alert(`Invalid zip code(s): ${invalidZips.map(z => z.code).join(', ')}\nPlease enter 5-digit zip codes only.`);
                    return false;
                }
                return true;
            }

// Get project ID from URL or data attribute
            function getCurrentProjectId() {
                // Try to get from URL first
                const urlMatch = window.location.pathname.match(/\/market_areas\/(\d+)/);
                if (urlMatch) {
                    return urlMatch[1];
                }
                
                // Fallback to data attribute if present
                const container = document.getElementById('mad-defs-container');
                if (container && container.dataset.projectId) {
                    return container.dataset.projectId;
                }
                
                return null;
            }
            // Function to update an existing MA
            function updateMA(id, maData) {
                const index = marketAreas.findIndex(ma => ma.id === id);
                if (index !== -1) {
                    marketAreas[index] = {
                        ...marketAreas[index],
                        ...maData
                    };
                    updateMAList();
                    updateMap(id);
                }
            }


            // Global variable to track ArcGIS loading state
            let arcgisLoaded = false;

            // Function to ensure ArcGIS is loaded
            async function ensureArcGISLoaded() {
                if (arcgisLoaded) return;
                
                return new Promise((resolve, reject) => {
                    if (typeof require !== 'undefined') {
                        arcgisLoaded = true;
                        resolve();
                    } else {
                        // Wait for ArcGIS to load
                        const checkRequire = setInterval(() => {
                            if (typeof require !== 'undefined') {
                                clearInterval(checkRequire);
                                arcgisLoaded = true;
                                resolve();
                            }
                        }, 100);

                        // Timeout after 10 seconds
                        setTimeout(() => {
                            clearInterval(checkRequire);
                            reject(new Error('ArcGIS failed to load'));
                        }, 10000);
                    }
                });
            }

            // Helper function to validate census tract IDs
            function validateCensusTractId(geoid) {
                // Census tract GEOIDs should be 11 digits
                if (!geoid || typeof geoid !== 'string' || geoid.length !== 11) {
                    console.warn(`Invalid census tract GEOID format: ${geoid}`);
                    return false;
                }
                
                // Should be numeric
                if (!/^\d+$/.test(geoid)) {
                    console.warn(`Census tract GEOID contains non-numeric characters: ${geoid}`);
                    return false;
                }
                
                // First 2 digits: State FIPS (01-56)
                // Next 3 digits: County FIPS (001-999)
                // Last 6 digits: Tract number (000100-998999)
                const stateFips = geoid.substring(0, 2);
                const countyFips = geoid.substring(2, 5);
                const tractNum = geoid.substring(5);
                
                if (parseInt(stateFips) < 1 || parseInt(stateFips) > 56) {
                    console.warn(`Invalid state FIPS in census tract GEOID: ${stateFips}`);
                    return false;
                }
                
                if (parseInt(countyFips) < 1 || parseInt(countyFips) > 999) {
                    console.warn(`Invalid county FIPS in census tract GEOID: ${countyFips}`);
                    return false;
                }
                
                return true;
            }

            // Helper function to handle place market areas
            function handlePlaceMarketArea(ma, Point, SimpleMarkerSymbol, Graphic, graphicsLayer) {
                const graphics = ma.areas.map(place => {
                    if (!place.location || !place.location.x || !place.location.y) {
                        console.warn(`Place missing location data:`, place);
                        return null;
                    }

                    const point = new Point({
                        longitude: place.location.x,
                        latitude: place.location.y,
                        spatialReference: { wkid: 4326 }
                    });

                    const symbol = new SimpleMarkerSymbol({
                        style: "circle",
                        size: 12,
                        color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                        outline: ma.borderWeight > 0 ? {
                            color: ma.borderColor,
                            width: ma.borderWeight
                        } : {
                            color: [0, 0, 0, 0.3],
                            width: 1
                        }
                    });

                    const graphic = new Graphic({
                        geometry: point,
                        symbol: symbol,
                        attributes: {
                            id: ma.id,
                            name: ma.name,
                            type: 'place',
                            placeId: place.placeId,
                            placeName: place.name
                        }
                    });

                    graphicsLayer.add(graphic);
                    return graphic;
                }).filter(Boolean);

                return graphics[0] || null;
            }

            // Function to toggle market area visibility
            async function toggleMAVisibility(id) {
                const ma = marketAreas.find(ma => ma.id === id);
                if (!ma) return;

                // Toggle visibility
                ma.visible = !ma.visible;
                updateMAList();

                try {
                    // Initialize map zoom parameters
                    const zoomOptions = {
                        duration: 1000,
                        easing: "ease-out",
                        padding: {
                            top: 50,
                            bottom: 50,
                            left: 50,
                            right: 50
                        }
                    };

                    // If we made an area visible, zoom to that specific area
                    if (ma.visible) {
                        await zoomToMarketArea(ma, zoomOptions);
                    } else {
                        // If we hid an area, zoom to all remaining visible areas
                        const visibleAreas = marketAreas.filter(area => area.visible);
                        if (visibleAreas.length > 0) {
                            await zoomToVisibleAreas(visibleAreas, zoomOptions);
                        }
                    }

                    // Update the map display
                    updateMap();
                } catch (error) {
                    console.error('Error handling visibility toggle:', error);
                }
            }

            // Update the getFullBlockGroupData helper function
            function getFullBlockGroupData(area) {
                console.log('[getFullBlockGroupData] Processing area:', area);
                
                // Get all possible versions of IDs
                const geoid = area.geoid || area.GEOID || area.attributes?.GEOID;
                let blockGroupId = area.blockGroupId || area.BLKGRP || area.attributes?.BLKGRP;
                let tractId = area.tractId || area.TRACT || area.attributes?.TRACT;
                let stateId = area.stateId || area.STATEFP || area.attributes?.STATEFP;
                let countyId = area.countyId || area.COUNTYFP || area.attributes?.COUNTYFP;
                const population = area.population || area.POP100 || area.attributes?.POP100;

                // If we have a full GEOID, parse it
                if (geoid && (!blockGroupId || !tractId || !stateId || !countyId)) {
                    console.log('[getFullBlockGroupData] Parsing GEOID:', geoid);
                    if (geoid.length === 12) {
                        stateId = geoid.slice(0, 2);
                        countyId = geoid.slice(2, 5);
                        tractId = geoid.slice(5, 11);
                        blockGroupId = geoid.slice(-1);
                    }
                }

                const data = {
                    geoid: geoid,
                    blockGroupId: blockGroupId,
                    tractId: tractId,
                    stateId: stateId,
                    countyId: countyId,
                    population: population,
                    GEOID: geoid,
                    BLKGRP: blockGroupId,
                    TRACT: tractId,
                    STATEFP: stateId,
                    COUNTYFP: countyId,
                    POP100: population
                };

                console.log('[getFullBlockGroupData] Extracted data:', data);
                return data;
            }


            async function zoomToMarketArea(ma, zoomOptions) {
                console.log('[zoomToMarketArea] Starting zoom for type:', ma.type);
                console.log('[zoomToMarketArea] Market area data:', ma);
                
                try {
                    await ensureArcGISLoaded();

                    require([
                        "esri/geometry/Extent",
                        "esri/rest/query",
                        "esri/rest/support/Query"
                    ], function(Extent, query, Query) {
                        let queryUrl;
                        let queryParams = new Query({
                            outSpatialReference: { wkid: 102100 },
                            returnGeometry: true,
                            outFields: ["*"]
                        });

                        switch(ma.type) {
                            case 'blockgroup':
                                queryUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Tracts_Blocks/MapServer/1";
                                
                                // Process each block group area
                                const blockGroupGeoids = ma.areas.map(area => {
                                    const data = getFullBlockGroupData(area);
                                    return data.geoid;
                                }).filter(id => id);

                                if (blockGroupGeoids.length > 0) {
                                    queryParams.where = `GEOID IN ('${blockGroupGeoids.join("','")}')`;
                                } else {
                                    console.error('[zoomToMarketArea] No valid block group GEOIDs found');
                                    return;
                                }
                                
                                console.log('[zoomToMarketArea] Block Group query:', {
                                    url: queryUrl,
                                    where: queryParams.where,
                                    geoids: blockGroupGeoids
                                });
                                break;


                            case 'block':
                                queryUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Tracts_Blocks/MapServer/12";
                                queryParams.where = `GEOID IN ('${ma.areas.map(a => a.geoid || a.GEOID).join("','")}')`;
                                console.log('[zoomToMarketArea] Block query:', queryParams.where);
                                break;

                            case 'place':
                                // Updated URL for places
                                queryUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/Places_CouSub_ConCity_SubMCD/MapServer/5";
                                const placeIds = ma.areas.map(a => 
                                    a.placeId || a.PLACEFP || a.geoid || a.GEOID
                                ).filter(id => id);
                                queryParams.where = `GEOID IN ('${placeIds.join("','")}')`;
                                console.log('[zoomToMarketArea] Place query:', {
                                    url: queryUrl,
                                    where: queryParams.where,
                                    placeIds: placeIds
                                });
                                break;

                            case 'zip':
                                queryUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_ZIP_Codes/FeatureServer/0";
                                queryParams.where = `ZIP IN ('${ma.areas.map(a => a.code).join("','")}')`;
                                break;

                            case 'county':
                                queryUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Counties/FeatureServer/0";
                                queryParams.where = ma.areas.map(county => {
                                    const parts = county.fullName.split(',').map(part => part.trim());
                                    return `(NAME = '${parts[0]}' AND STATE_NAME = '${parts[1]}')`;
                                }).join(" OR ");
                                break;

                            case 'tract':
                                queryUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Census2020/MapServer/6";
                                queryParams.where = `GEOID IN ('${ma.areas.map(a => a.geoid || a.GEOID).join("','")}')`;
                                break;

                            case 'drivetime':
                                if (ma.areas.length > 0 && ma.areas[0].geometry) {
                                    mapViewInstance.goTo(ma.areas[0].geometry, zoomOptions);
                                }
                                return;

                            case 'radius':
                                if (ma.areas.length > 0 && ma.areas[0].geometries) {
                                    const geometries = ma.areas[0].geometries;
                                    mapViewInstance.goTo(geometries, zoomOptions);
                                }
                                return;

                            default:
                                console.error('[zoomToMarketArea] Unknown market area type:', ma.type);
                                return;
                        }

                        // Execute query and zoom to results
                        console.log('[zoomToMarketArea] Executing query:', {
                            url: queryUrl,
                            params: queryParams
                        });

                        // Execute query and zoom to results
                        console.log('[zoomToMarketArea] Executing query:', {
                            url: queryUrl,
                            params: queryParams
                        });

                        query.executeQueryJSON(queryUrl, queryParams)
                            .then(results => {
                                console.log('[zoomToMarketArea] Query results:', results);
                                if (results.features && results.features.length > 0) {
                                    console.log('[zoomToMarketArea] Found features:', results.features.length);
                                    mapViewInstance.goTo(results.features, {
                                        ...zoomOptions,
                                        animate: true
                                    }).catch(error => {
                                        console.error('[zoomToMarketArea] Error during zoom:', error);
                                    });
                                } else {
                                    console.log('[zoomToMarketArea] No features found for zoom');
                                }
                            })
                            .catch(error => {
                                console.error('[zoomToMarketArea] Error querying features:', error);
                            });
                    });
                } catch (error) {
                    console.error('[zoomToMarketArea] Error:', error);
                }
            }


            // Helper function to zoom to all visible market areas
            async function zoomToVisibleAreas(visibleAreas, zoomOptions) {
                try {
                    await ensureArcGISLoaded();

                    require([
                        "esri/geometry/Extent",
                        "esri/rest/query",
                        "esri/rest/support/Query",
                        "esri/geometry/geometryEngine"
                    ], function(Extent, query, Query, geometryEngine) {
                        // Create an array to hold all query promises
                        const queryPromises = visibleAreas.map(ma => {
                            let queryUrl;
                            let queryParams = new Query({
                                outSpatialReference: { wkid: 102100 },
                                returnGeometry: true
                            });

                            switch(ma.type) {
                                case 'zip':
                                    queryUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_ZIP_Codes/FeatureServer/0";
                                    queryParams.where = `ZIP IN ('${ma.areas.map(a => a.code).join("','")}')`;
                                    return query.executeQueryJSON(queryUrl, queryParams);
                                case 'county':
                                    queryUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Counties/FeatureServer/0";
                                    queryParams.where = ma.areas.map(county => {
                                        const parts = county.fullName.split(',').map(part => part.trim());
                                        return `(NAME = '${parts[0]}' AND STATE_NAME = '${parts[1]}')`;
                                    }).join(" OR ");
                                    return query.executeQueryJSON(queryUrl, queryParams);
                                case 'tract':
                                    queryUrl = "https://tigerweb.geo.census.gov/arcgis/rest/services/TIGERweb/tigerWMS_Census2020/MapServer/6";
                                    queryParams.where = `GEOID IN ('${ma.areas.map(a => a.geoid).join("','")}')`;
                                    return query.executeQueryJSON(queryUrl, queryParams);
                                case 'place':
                                    return Promise.resolve({ 
                                        features: ma.areas.map(area => ({
                                            geometry: {
                                                type: "point",
                                                longitude: area.location.x,
                                                latitude: area.location.y
                                            }
                                        }))
                                    });
                                case 'drivetime':
                                    return Promise.resolve({
                                        features: ma.areas.map(area => ({ geometry: area.geometry }))
                                    });
                                case 'radius':
                                    return Promise.resolve({
                                        features: ma.areas.flatMap(area => 
                                            area.geometries.map(geometry => ({ geometry }))
                                        )
                                    });
                                default:
                                    return Promise.resolve({ features: [] });
                            }
                        });

                        // Wait for all queries to complete and zoom to combined extent
                        Promise.all(queryPromises).then(results => {
                            const allFeatures = results.flatMap(result => result.features || []);
                            if (allFeatures.length > 0) {
                                mapViewInstance.goTo(allFeatures, zoomOptions);
                            }
                        }).catch(error => {
                            console.error('Error getting combined extent:', error);
                        });
                    });
                } catch (error) {
                    console.error('Error in zoomToVisibleAreas:', error);
                }
            }

            // Function to toggle market area visibility
            async function toggleMAVisibility(id) {
                const ma = marketAreas.find(ma => ma.id === id);
                if (!ma) return;

                // Toggle visibility
                ma.visible = !ma.visible;
                updateMAList();

                try {
                    // Initialize map zoom parameters
                    const zoomOptions = {
                        duration: 1000,
                        easing: "ease-out",
                        padding: {
                            top: 50,
                            bottom: 50,
                            left: 50,
                            right: 50
                        }
                    };

                    // If we made an area visible, zoom to that specific area
                    if (ma.visible) {
                        await zoomToMarketArea(ma, zoomOptions);
                    } else {
                        // If we hid an area, zoom to all remaining visible areas
                        const visibleAreas = marketAreas.filter(area => area.visible);
                        if (visibleAreas.length > 0) {
                            await zoomToVisibleAreas(visibleAreas, zoomOptions);
                        }
                    }

                    // Update the map display
                    updateMap();
                } catch (error) {
                    console.error('Error handling visibility toggle:', error);
                }
            }


            async function updateMap(updatedMAId = null, shouldZoom = false) {
                try {
                    await ensureArcGISLoaded();

                    require([
                        "esri/layers/GraphicsLayer",
                        "esri/Graphic",
                        "esri/geometry/geometryEngine",
                        "esri/geometry/support/jsonUtils",
                        "esri/geometry/SpatialReference",
                        "esri/config",
                        "esri/geometry/Extent"
                    ], function(GraphicsLayer, Graphic, geometryEngine, jsonUtils, SpatialReference, esriConfig, Extent) {
                        console.log('UPDATE MAP Starting map update');
                        
                        if (!mapViewInstance || !mapViewInstance.map) {
                            console.error('Map not initialized');
                            return;
                        }

                        // Clear existing graphics layer
                        const existingLayers = mapViewInstance.map.layers.filter(layer => layer.id === "graphicsLayer");
                        existingLayers.forEach(layer => mapViewInstance.map.remove(layer));

                        const graphicsLayer = new GraphicsLayer({ id: "graphicsLayer" });
                        mapViewInstance.map.add(graphicsLayer);

                        // Array to store all graphics for extent calculation
                        let allGraphics = [];
                        
                        // Process each visible market area
                        const renderPromises = marketAreas.filter(ma => ma.visible).map(async ma => {
                            console.log(`Processing market area: ${ma.id}, type: ${ma.type}`);

                            let graphics = [];

                            try {
                                switch (ma.type) {
                                    case 'cbsa':
                                        const cbsaFeatures = await queryFeatures(mapViewInstance.extent, 'cbsa');
                                        if (cbsaFeatures && cbsaFeatures.length > 0) {
                                            cbsaFeatures.forEach(feature => {
                                                const isSelected = ma.areas.some(area => 
                                                    area.cbsaId === feature.attributes.CBSAFP
                                                );

                                                if (isSelected) {
                                                    const graphic = new Graphic({
                                                        geometry: feature.geometry,
                                                        symbol: {
                                                            type: "simple-fill",
                                                            color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                                                            outline: ma.borderWeight > 0 ? {
                                                                color: ma.borderColor,
                                                                width: ma.borderWeight
                                                            } : null
                                                        },
                                                        attributes: {
                                                            id: ma.id,
                                                            name: ma.name,
                                                            type: 'cbsa',
                                                            cbsaId: feature.attributes.CBSAFP,
                                                            cbsaName: feature.attributes.NAME,
                                                            memi: feature.attributes.MEMI
                                                        }
                                                    });
                                                    graphics.push(graphic);
                                                    graphicsLayer.add(graphic);
                                                }
                                            });
                                        }
                                        break;

                                    case 'place':
                                        const placeFeatures = await queryFeatures(mapViewInstance.extent, 'place');
                                        if (placeFeatures && placeFeatures.length > 0) {
                                            placeFeatures.forEach(feature => {
                                                const isSelected = ma.areas.some(area => 
                                                    area.placeId === feature.attributes.GEOID || 
                                                    area.geoid === feature.attributes.GEOID
                                                );

                                                if (isSelected) {
                                                    const graphic = new Graphic({
                                                        geometry: feature.geometry,
                                                        symbol: {
                                                            type: "simple-fill",
                                                            color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                                                            outline: ma.borderWeight > 0 ? {
                                                                color: ma.borderColor,
                                                                width: ma.borderWeight
                                                            } : null
                                                        },
                                                        attributes: {
                                                            id: ma.id,
                                                            name: ma.name,
                                                            type: 'place',
                                                            placeId: feature.attributes.GEOID,
                                                            placeName: feature.attributes.NAME
                                                        }
                                                    });
                                                    graphics.push(graphic);
                                                    graphicsLayer.add(graphic);
                                                }
                                            });
                                        }
                                        break;

                                    case 'drivetime':
                                        graphics = ma.areas.map(area => {
                                            const pointGraphic = new Graphic({
                                                geometry: area.centerPoint,
                                                symbol: {
                                                    type: "simple-marker",
                                                    style: "circle",
                                                    color: [255, 0, 0],
                                                    size: 8
                                                }
                                            });

                                            const polygonGraphic = new Graphic({
                                                geometry: area.geometry,
                                                symbol: {
                                                    type: "simple-fill",
                                                    color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                                                    outline: {
                                                        color: ma.borderColor,
                                                        width: ma.borderWeight
                                                    }
                                                },
                                                attributes: {
                                                    id: ma.id,
                                                    name: ma.name,
                                                    type: ma.type
                                                }
                                            });

                                            graphicsLayer.addMany([polygonGraphic, pointGraphic]);
                                            return polygonGraphic;
                                        });
                                        break;

                                    case 'radius':
                                        graphics = ma.areas.flatMap(area => {
                                            const pointGraphic = new Graphic({
                                                geometry: area.centerPoint,
                                                symbol: {
                                                    type: "simple-marker",
                                                    style: "circle",
                                                    color: [255, 0, 0],
                                                    size: 8
                                                }
                                            });

                                            const circleGraphics = area.geometries.map(geometry => 
                                                new Graphic({
                                                    geometry: geometry,
                                                    symbol: {
                                                        type: "simple-fill",
                                                        color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                                                        outline: {
                                                            color: ma.borderColor,
                                                            width: ma.borderWeight
                                                        }
                                                    },
                                                    attributes: {
                                                        id: ma.id,
                                                        name: ma.name,
                                                        type: ma.type
                                                    }
                                                })
                                            );

                                            graphicsLayer.add(pointGraphic);
                                            circleGraphics.forEach(g => graphicsLayer.add(g));
                                            return [...circleGraphics, pointGraphic];
                                        });
                                        break;

                                    case 'zip':
                                    case 'county':
                                    case 'tract':
                                        const features = await queryFeatures(mapViewInstance.extent, ma.type);
                                        if (features && features.length > 0) {
                                            features.forEach(feature => {
                                                const isFeatureInMA = ma.areas.some(area => {
                                                    switch(ma.type) {
                                                        case 'zip':
                                                            return area.code === feature.attributes.ZIP;
                                                        case 'county':
                                                            const countyState = `${feature.attributes.NAME}, ${feature.attributes.STATE_NAME}`;
                                                            return area.fullName === countyState;
                                                        case 'tract':
                                                            return area.geoid === feature.attributes.GEOID20 || 
                                                                area.geoid === feature.attributes.GEOID ||
                                                                area.tractId === feature.attributes.TRACTCE20;
                                                        default:
                                                            return false;
                                                    }
                                                });

                                                if (isFeatureInMA) {
                                                    const graphic = new Graphic({
                                                        geometry: feature.geometry,
                                                        symbol: {
                                                            type: "simple-fill",
                                                            color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                                                            outline: ma.borderWeight > 0 ? {
                                                                color: ma.borderColor,
                                                                width: ma.borderWeight
                                                            } : null
                                                        },
                                                        attributes: {
                                                            id: ma.id,
                                                            name: ma.name,
                                                            type: ma.type,
                                                            ...(ma.type === 'tract' ? {
                                                                geoid: feature.attributes.GEOID20 || feature.attributes.GEOID,
                                                                tractId: feature.attributes.TRACTCE20,
                                                                stateId: feature.attributes.STATEFP20,
                                                                countyId: feature.attributes.COUNTYFP20
                                                            } : {})
                                                        }
                                                    });

                                                    graphics.push(graphic);
                                                    graphicsLayer.add(graphic);
                                                }
                                            });
                                        }
                                        break;
                                }

                                return graphics;
                            } catch (error) {
                                console.error(`Error processing market area ${ma.id}:`, error);
                                return [];
                            }
                        });

                        // Handle zooming after all graphics are added
                        Promise.all(renderPromises).then(graphicsArrays => {
                            const allGraphics = graphicsArrays.flat().filter(Boolean);

                            if (allGraphics.length > 0 && shouldZoom) {
                                if (updatedMAId) {
                                    // Zoom to specific MA if ID provided
                                    const maGraphics = allGraphics.filter(g => g.attributes?.id === updatedMAId);
                                    if (maGraphics.length > 0) {
                                        mapViewInstance.goTo(maGraphics, {
                                            padding: { top: 50, bottom: 50, left: 50, right: 50 }
                                        });
                                    }
                                } else {
                                    // Zoom to show all visible areas
                                    mapViewInstance.goTo(allGraphics, {
                                        padding: { top: 50, bottom: 50, left: 50, right: 50 }
                                    });
                                }
                            }
                        }).catch(error => {
                            console.error('Error processing graphics:', error);
                        });
                    });
                } catch (error) {
                    console.error('Error in updateMap:', error);
                }
            }




            function processExcelColor(excelColor) {
                console.log('processExcelColor called with:', {
                    type: typeof excelColor,
                    value: excelColor,
                    objectKeys: excelColor && typeof excelColor === 'object' ? Object.keys(excelColor) : 'not an object'
                });

                // Default color if none is found
                if (!excelColor) {
                    console.log('No color provided, using default red');
                    return '#FF0000';
                }

                try {
                    // If it's already a hex color
                    if (typeof excelColor === 'string' && excelColor.startsWith('#')) {
                        console.log('Found hex color string:', excelColor);
                        return excelColor;
                    }

                    // If it's an RGB string
                    if (typeof excelColor === 'string' && excelColor.startsWith('rgb')) {
                        console.log('Found RGB string:', excelColor);
                        const matches = excelColor.match(/\d+/g);
                        if (matches && matches.length >= 3) {
                            const [r, g, b] = matches.map(Number);
                            const result = rgbToHex(r, g, b);
                            console.log('Converted RGB to hex:', result);
                            return result;
                        }
                    }

                    // If it's a number
                    if (typeof excelColor === 'number') {
                        console.log('Found numeric color:', excelColor);
                        const b = (excelColor >> 16) & 0xFF;
                        const g = (excelColor >> 8) & 0xFF;
                        const r = excelColor & 0xFF;
                        const result = rgbToHex(r, g, b);
                        console.log('Converted numeric color to hex:', result);
                        return result;
                    }

                    // If it's an object with rgb values
                    if (excelColor.rgb) {
                        console.log('Found color object with RGB:', excelColor.rgb);
                        let colorStr = excelColor.rgb.toString(16);
                        console.log('Initial color string:', colorStr);
                        
                        // Remove alpha channel if present
                        if (colorStr.length === 8) {
                            colorStr = colorStr.substring(2);
                            console.log('Removed alpha channel:', colorStr);
                        }
                        
                        // Ensure 6 digits
                        while (colorStr.length < 6) {
                            colorStr = '0' + colorStr;
                        }
                        const result = '#' + colorStr;
                        console.log('Final processed color:', result);
                        return result;
                    }

                    // If it's an object with other color properties
                    if (typeof excelColor === 'object') {
                        console.log('Color object properties:', {
                            rgb: excelColor.rgb,
                            theme: excelColor.theme,
                            tint: excelColor.tint,
                            argb: excelColor.argb,
                            indexed: excelColor.indexed
                        });
                        
                        // Try ARGB if available
                        if (excelColor.argb) {
                            const result = '#' + excelColor.argb.substring(2);
                            console.log('Processed ARGB color:', result);
                            return result;
                        }
                    }

                    console.log('No valid color format found, using default red');
                    return '#FF0000';
                } catch (e) {
                    console.error('Error processing color:', e);
                    console.error('Error stack:', e.stack);
                    return '#FF0000';
                }
            }


            // Helper function to convert RGB to Hex
            function rgbToHex(r, g, b) {
                return '#' + [r, g, b].map(x => {
                    const hex = x.toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }
        
            // Function to handle the color from Excel
            function processExcelColor(cell) {
                // If no cell or no fill, return default red
                if (!cell || !cell.fill) return '#FF0000';

                try {
                    // Get the fill color (rgbString is already formatted with # prefix)
                    const fillColor = cell.fill.fgColor.rgb || cell.fill.fgColor.rgbString;
                    
                    if (!fillColor) return '#FF0000';

                    // If color starts with FF (alpha channel), remove it
                    let colorValue = fillColor.toString();
                    if (colorValue.length === 8) {
                        colorValue = colorValue.substring(2);
                    }

                    // Ensure hex format
                    return colorValue.startsWith('#') ? colorValue : `#${colorValue}`;
                } catch (error) {
                    console.error('Error extracting cell color:', error);
                    return '#FF0000'; // Default to red on error
                }
            }


            document.getElementById('importExcelButton').addEventListener('click', function() {
                document.getElementById('importExcelInput').click();
            });

            function processExcelImport(data) {
                if (data.success) {
                    console.log('Processing market areas:', data.market_areas);
                    
                    // Clear existing market areas
                    marketAreas = [];
                    
                    // Convert all market areas first
                    data.market_areas.forEach((ma, idx) => {
                        const isZip = ma.definitionType.toUpperCase() === 'ZCTA';
                        
                        const maData = {
                            type: isZip ? 'zip' : 'county',
                            name: ma.fullName,
                            shortName: ma.shortName,
                            fillColor: ma.fillColor,
                            borderColor: ma.fillColor,
                            transparency: 50,
                            borderWeight: 1,
                            visible: true,
                            areas: []
                        };

                        if (isZip) {
                            maData.areas = ma.definition.split(',')
                                .map(zip => zip.trim())
                                .filter(zip => zip.length > 0)
                                .map(code => ({
                                    code: code
                                }));
                        } else {
                            let countyName = ma.county || '';
                            let stateName = ma.state || '';
                            
                            if (countyName.includes(',')) {
                                const parts = countyName.split(',');
                                countyName = parts[0].trim();
                                stateName = parts[1].trim();
                            }
                            
                            countyName = countyName.replace(/\s+County$/i, '').trim();
                            
                            maData.areas = [{
                                name: countyName,
                                fullName: `${countyName} County, ${stateName}`
                            }];
                        }

                        if (maData.areas.length > 0) {
                            addNewMA(maData);
                        }
                    });

                    // After adding all market areas, update the map with zooming
                    require([
                        "esri/layers/GraphicsLayer",
                        "esri/Graphic",
                        "esri/rest/support/Query",
                        "esri/rest/query",
                        "esri/geometry/geometryEngine"
                    ], function(GraphicsLayer, Graphic, Query, query, geometryEngine) {
                        if (!mapViewInstance) {
                            console.error("MapView instance not found.");
                            return;
                        }

                        // Remove existing GraphicsLayer
                        const existingLayers = mapViewInstance.map.layers.filter(layer => layer.id === "graphicsLayer");
                        existingLayers.forEach(layer => mapViewInstance.map.remove(layer));

                        const graphicsLayer = new GraphicsLayer({ id: "graphicsLayer" });
                        mapViewInstance.map.add(graphicsLayer);

                        // Create an array to hold all geometry promises
                        const geometryPromises = marketAreas.map(ma => {
                            let queryUrl, whereClause;
                            
                            if (ma.type === 'zip') {
                                queryUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_ZIP_Codes/FeatureServer/0/query";
                                whereClause = `ZIP IN (${ma.areas.map(a => `'${a.code}'`).join(',')})`;
                            } else {
                                queryUrl = "https://services.arcgis.com/P3ePLMYs2RVChkJx/ArcGIS/rest/services/USA_Counties/FeatureServer/0/query";
                                whereClause = ma.areas.map(county => {
                                    const parts = county.fullName.split(',');
                                    const countyName = parts[0].trim();
                                    const stateName = getStateFullName(parts[1].trim());
                                    return `(NAME = '${countyName}' AND STATE_NAME = '${stateName}')`;
                                }).join(" OR ");
                            }

                            return query.executeQueryJSON(queryUrl, {
                                where: whereClause,
                                outFields: ["*"],
                                returnGeometry: true,
                                f: "json"
                            }).then(result => {
                                if (!result.features || !result.features.length) return null;
                                
                                // Combine all geometries for this market area
                                return result.features.reduce((combined, feature) => {
                                    return combined ? 
                                        geometryEngine.union([combined, feature.geometry]) : 
                                        feature.geometry;
                                }, null);
                            });
                        });

                        // Wait for all geometries to load
                        Promise.all(geometryPromises)
                            .then(geometries => {
                                // Filter out null geometries and combine all
                                const validGeometries = geometries.filter(g => g !== null);
                                if (validGeometries.length === 0) return;

                                // Combine all market area geometries
                                const combinedGeometry = validGeometries.reduce((combined, geometry) => {
                                    return combined ? 
                                        geometryEngine.union([combined, geometry]) : 
                                        geometry;
                                });

                                // Create and add graphics
                                marketAreas.forEach((ma, index) => {
                                    if (ma.visible && geometries[index]) {
                                        const fillSymbol = {
                                            type: "simple-fill",
                                            color: hexToRGBA(ma.fillColor, (100 - ma.transparency) / 100),
                                            outline: ma.borderWeight > 0 ? {
                                                color: ma.borderColor,
                                                width: ma.borderWeight
                                            } : null
                                        };
                                        
                                        const graphic = new Graphic({
                                            geometry: geometries[index],
                                            symbol: fillSymbol
                                        });
                                        
                                        graphicsLayer.add(graphic);
                                    }
                                });

                                // Zoom to the combined extent
                                if (combinedGeometry) {
                                    mapViewInstance.goTo({
                                        target: combinedGeometry,
                                        padding: { top: 50, bottom: 50, left: 50, right: 50 }
                                    }, {
                                        duration: 1000,
                                        easing: "ease-out"
                                    });
                                }
                            })
                            .catch(error => {
                                console.error('Error processing geometries:', error);
                            });
                    });

                    updateMAList();
                } else {
                    console.error('Import failed:', data.errors);
                    alert(`Failed to import Market Areas:\n${data.errors.join('\n')}`);
                }
            }
            // Update the event listener for Excel import
            document.getElementById('importExcelInput').addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (!file) {
                    return;
                }

                // Validate file type
                const allowedExtensions = /(\.xls|\.xlsx|\.xlsm)$/i;
                if (!allowedExtensions.exec(file.name)) {
                    alert('Unsupported file type. Please upload a .xls, .xlsx, or .xlsm file.');
                    event.target.value = '';
                    return;
                }

                // Create FormData and append file and project ID
                const formData = new FormData();
                formData.append('maExcelFile', file);
                formData.append('project_id', currentProjectId);

                // Show loading indicator
                showLoadingIndicator(true);

                fetch('/import_market_areas', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    showLoadingIndicator(false);
                    processExcelImport(data);
                })
                .catch(error => {
                    showLoadingIndicator(false);
                    console.error('Import error:', error);
                    console.error('Error stack:', error.stack);
                    alert('An error occurred while importing Market Areas. Please try again.');
                });

                // Clear the file input
                event.target.value = '';
            });
            
            // Add this helper function to properly format county names
            function formatCountyName(name, state) {
                // Remove 'County' if it exists
                let countyName = name.replace(/\s+County$/i, '').trim();
                
                // If state is provided, format as "County Name, STATE"
                if (state) {
                    // Convert state to uppercase and ensure it's just the abbreviation
                    const stateAbbr = state.trim().toUpperCase();
                    return `${countyName}, ${stateAbbr}`;
                }
                
                return countyName;
            }
            
            // Function to show/hide a loading indicator (implement as needed)
            function showLoadingIndicator(show) {
                // Example implementation:
                const loader = document.getElementById('loader');
                if (loader) {
                    loader.style.display = show ? 'block' : 'none';
                }
            }

            function fetchMarketAreas() {
                fetch(`/market_areas/${currentProjectId}`)
                    .then(response => response.text())
                    .then(html => {
                        // Parse the response HTML and extract the MA list
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const newMAList = doc.querySelector('#ma-list');
                        if (newMAList) {
                            document.getElementById('ma-list').innerHTML = newMAList.innerHTML;
                            updateMAList(); // Re-initialize event listeners or any dynamic content
                            updateMap();    // Update the map to reflect the new Market Areas
                        } else {
                            console.error('Could not find ma-list in the fetched HTML.');
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching Market Areas:', error);
                    });
            }

            // Add this function to load saved market areas when initializing the page
            function loadSavedMarketAreas() {
                const projectId = getCurrentProjectId();
                if (!projectId) {
                    console.error('Project ID not found');
                    return;
                }

                fetch(`/load_market_areas/${projectId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.marketAreas) {
                            // Clear existing market areas
                            marketAreas = [];
                            
                            // Load saved market areas
                            data.marketAreas.forEach(ma => {
                                marketAreas.push({
                                    id: ma.id,
                                    type: ma.type,
                                    name: ma.name,
                                    shortName: ma.shortName,
                                    acs: ma.acs,
                                    areas: ma.areas,
                                    fillColor: ma.fillColor,
                                    borderColor: ma.borderColor,
                                    transparency: ma.transparency,
                                    borderWeight: ma.borderWeight,
                                    visible: ma.visible !== undefined ? ma.visible : true,
                                    order: ma.order
                                });
                            });

                            // Update UI
                            updateMAList();
                            updateMap();
                        }
                    })
                    .catch(error => {
                        console.error('Error loading market areas:', error);
                    });
            }

            function saveAndExit() {
                // Get current project ID
                const projectId = getCurrentProjectId();
                if (!projectId) {
                    alert('Project ID not found');
                    return;
                }

                // Show loading indicator or disable button to prevent double-clicks
                const saveButton = document.querySelector('.header-buttons .green-button');
                const originalText = saveButton.textContent;
                saveButton.disabled = true;
                saveButton.textContent = 'Saving...';

                // Prepare market areas data
                const marketAreasData = marketAreas.map(ma => ({
                    id: ma.id,
                    type: ma.type,
                    name: ma.name,
                    shortName: ma.shortName || '',
                    acs: ma.acs || false,
                    areas: ma.areas,
                    fillColor: ma.fillColor,
                    borderColor: ma.borderColor,
                    transparency: ma.transparency,
                    borderWeight: ma.borderWeight,
                    visible: ma.visible,
                    order: ma.order
                }));

                // Save to server
                fetch(`/save_market_areas/${projectId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ marketAreas: marketAreasData })
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        // Redirect to projects page on success
                        window.location.href = "/projects";
                    } else {
                        // If there was a server-side error
                        throw new Error(data.error || 'Unknown error saving market areas');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Error saving market areas. Please try again.');
                    // Reset button state
                    saveButton.disabled = false;
                    saveButton.textContent = originalText;
                });
            }       
            // Function to add a new MA to the list
            function addNewMA(maData) {
                const newMA = {
                    id: marketAreas.length + 1,
                    order: marketAreas.length,
                    visible: true,
                    ...maData
                };
                
                marketAreas.push(newMA);
                updateMAList();
                updateMap(newMA.id);
                return newMA;
            }

            // Updated market area list function with better FIPS handling
            function updateMAList() {
                const maList = document.getElementById('ma-list');
                if (!maList) return;

                maList.innerHTML = '';
                
                // Sort market areas by order
                const sortedMAs = [...marketAreas].sort((a, b) => a.order - b.order);
                
                // Process each market area
                for (const ma of sortedMAs) {
                    const maItem = createMAListItem(ma);
                    maList.appendChild(maItem);

                    // Handle county FIPS codes
                    if (ma.type === 'county') {
                        ma.areas.forEach(async area => {
                            if (!area.fipsCode) {
                                try {
                                    const { countyName, stateName } = parseCountyInfo(area);
                                    if (countyName && stateName) {
                                        const fipsCode = await getFipsCode(countyName, stateName);
                                        if (fipsCode) {
                                            area.fipsCode = fipsCode;
                                        }
                                    }
                                } catch (error) {
                                    console.error('Error processing county FIPS:', error);
                                }
                            } else {
                                // Display existing FIPS code
                            }
                        });
                    }
                }

                // Add drag and drop event listeners
                addDragAndDropListeners();
            }



            function dragStart(e) {
                e.dataTransfer.setData('text/plain', e.target.dataset.id);
                setTimeout(() => {
                    e.target.classList.add('dragging');
                }, 0);
            }
        
            function dragOver(e) {
                e.preventDefault();
                const draggingElement = document.querySelector('.dragging');
                const currentElement = e.currentTarget;
                const container = currentElement.parentNode;
                const afterElement = getDragAfterElement(container, e.clientY);
                
                if (afterElement == null) {
                    container.appendChild(draggingElement);
                } else {
                    container.insertBefore(draggingElement, afterElement);
                }
            }
        



        
            function drop(e) {
                e.preventDefault();
                const draggedId = parseInt(e.dataTransfer.getData('text'));
                updateMAOrder();
            }
        
            function dragEnd(e) {
                e.target.classList.remove('dragging');
                updateMAOrder(); // Update the order and redraw the map
            }
        
            // Drag and drop helper functions
            function handleDragStart(e) {
                e.dataTransfer.setData('text/plain', e.target.dataset.id);
                e.target.classList.add('dragging');
            }

            function handleDragOver(e) {
                e.preventDefault();
                const draggingItem = document.querySelector('.dragging');
                if (!draggingItem) return;
                
                const list = e.currentTarget.parentNode;
                const afterElement = getDragAfterElement(list, e.clientY);
                
                if (afterElement) {
                    list.insertBefore(draggingItem, afterElement);
                } else {
                    list.appendChild(draggingItem);
                }
            }

            function handleDrop(e) {
                e.preventDefault();
                document.querySelector('.dragging')?.classList.remove('dragging');
                updateMAOrder();
            }

            function handleDragEnd(e) {
                e.target.classList.remove('dragging');
                updateMAOrder();
            }

            function getDragAfterElement(container, y) {
                const draggableElements = [...container.querySelectorAll('.ma-item:not(.dragging)')];
                
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = y - box.top - box.height / 2;
                    
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            function updateMAOrder() {
                const maItems = document.querySelectorAll('.ma-item');
                maItems.forEach((item, index) => {
                    const ma = marketAreas.find(ma => ma.id === parseInt(item.dataset.id));
                    if (ma) {
                        ma.order = index;
                    }
                });
                
                // Sort the marketAreas array by the new order
                marketAreas.sort((a, b) => a.order - b.order);
                
                // Update the map to reflect the new order
                updateMap();
            }
        
        
            function showColorPicker(target) {
                currentColorTarget = target;
                const popup = document.getElementById('colorPickerPopup');
                const targetElement = document.getElementById(`${target}ColorDisplay`);
                
                // Position the popup
                const rect = targetElement.getBoundingClientRect();
                popup.style.top = `${rect.top}px`;
                popup.style.left = `${rect.right + 10}px`; // Adjust as needed
        
                // Show the popup
                popup.style.display = 'block';
                
                updateColorPaletteDisplay();
                updateRecentColorsDisplay();
            }
        
            function updateColorPaletteDisplay() {
                const container = document.getElementById('colorPaletteContainer');
                container.innerHTML = '';
                
                colorPalettes.forEach((palette, index) => {
                    const paletteSection = document.createElement('div');
                    paletteSection.className = 'color-section';
                    paletteSection.innerHTML = `
                        <h5>${palette.name}</h5>
                        <div id="palette-${index}" class="color-options"></div>
                    `;
                    container.appendChild(paletteSection);
                    
                    const colorContainer = paletteSection.querySelector(`#palette-${index}`);
                    palette.colors.slice(0, 20).forEach(color => {
                        const colorButton = createColorButton(color);
                        colorContainer.appendChild(colorButton);
                    });
                });
            }
        
            function updateRecentColorsDisplay() {
                const container = document.getElementById('recentColors');
                container.innerHTML = '';
                recentColors.slice(0, 20).forEach(color => {
                    const colorButton = createColorButton(color);
                    container.appendChild(colorButton);
                });
            }
        
            function createColorButton(color) {
                const colorButton = document.createElement('button');
                colorButton.className = 'color-option';
                colorButton.style.backgroundColor = color;
                colorButton.onclick = () => selectColor(color);
                colorButton.title = color; // Show color value on hover
                return colorButton;
            }
        
            function selectColor(color) {
                setColor(currentColorTarget, color);
                addToRecentColors(color);
                closeColorPicker();
            }
        
            function addToRecentColors(color) {
                const existingIndex = recentColors.indexOf(color);
                if (existingIndex !== -1) {
                    recentColors.splice(existingIndex, 1);
                }
                recentColors.unshift(color);
                if (recentColors.length > 20) {
                    recentColors.pop();
                }
                saveRecentColors();
            }
        
            function saveRecentColors() {
                localStorage.setItem('recentColors', JSON.stringify(recentColors));
            }
        
            function loadRecentColors() {
                const savedColors = localStorage.getItem('recentColors');
                if (savedColors) {
                    recentColors = JSON.parse(savedColors);
                }
            }
        
            function showMoreColorsDialog() {
                document.getElementById('colorPickerPopup').style.display = 'none';
                document.getElementById('moreColorsDialog').style.display = 'block';
                const currentColor = document.getElementById(`${currentColorTarget}Color`).value || '#000000';
                document.getElementById('customColorPicker').value = currentColor;
                document.getElementById('hexInput').value = currentColor;
            }
        
            function applyCustomColor() {
                const color = document.getElementById('customColorPicker').value;
                selectColor(color);
                closeMoreColorsDialog();
                closeColorPicker(); // Close the main color picker popup
            }
        
        
            function closeMoreColorsDialog() {
                document.getElementById('moreColorsDialog').style.display = 'none';
            }
            // Add this function to handle clicks outside the color picker
            function handleOutsideClick(event) {
                const popup = document.getElementById('colorPickerPopup');
                const colorDisplays = document.querySelectorAll('.color-display');
                
                if (!popup.contains(event.target) && !Array.from(colorDisplays).some(display => display.contains(event.target))) {
                    closeColorPicker();
                }
            }
        
            function closeColorPicker() {
                document.getElementById('colorPickerPopup').style.display = 'none';
            }
        
            function setColor(target, color) {
                const colorInput = document.getElementById(`${target}Color`);
                const colorDisplay = document.getElementById(`${target}ColorDisplay`);
                colorInput.value = color;
                colorDisplay.style.backgroundColor = color;
        
                // Sync the other color
                const otherTarget = target === 'fill' ? 'border' : 'fill';
                const otherColorInput = document.getElementById(`${otherTarget}Color`);
                const otherColorDisplay = document.getElementById(`${otherTarget}ColorDisplay`);
                otherColorInput.value = color;
                otherColorDisplay.style.backgroundColor = color;
            }
        

            async function editMA(id) {
                console.log('[editMA] Starting edit for MA:', id);
                const ma = marketAreas.find(ma => ma.id === id);
                if (!ma) {
                    console.error('[editMA] Market area not found:', id);
                    return;
                }

                try {
                    // First zoom to the market area before showing the form
                    await zoomToMarketArea(ma, {
                        padding: {
                            top: 50,
                            bottom: 50,
                            left: 50,
                            right: 50
                        },
                        duration: 1000,
                        easing: "ease-out"
                    });

                    // Show form and hide list
                    document.getElementById('ma-list').style.display = 'none';
                    document.getElementById('ma-form').style.display = 'flex';

                    console.log('[editMA] Market area found:', ma);
                    console.log('[editMA] Market area areas:', ma.areas);

                    // Set basic form fields
                    document.getElementById('maType').value = ma.type;
                    document.getElementById('maName').value = ma.name;
                    document.getElementById('shortName').value = ma.shortName || '';
                    document.getElementById('acsCheckbox').checked = ma.acs;

                    // Set colors and styles
                    setColor('fill', ma.fillColor);
                    setColor('border', ma.borderColor);
                    document.getElementById('transparency').value = ma.transparency;
                    document.getElementById('transparencyValue').value = ma.transparency;
                    document.getElementById('borderWeight').value = ma.borderWeight;
                    document.getElementById('noBorder').checked = ma.borderWeight === 0;

                    // Initialize interactive overlay with the correct type
                    await initializeInteractiveOverlay(ma.type);
                    
                    // Initialize location selector
                    initializeLocationSelector();
                    
                    // Convert existing areas to location format based on type
                    switch(ma.type) {
                        case 'block':
                            console.log('[editMA] Processing block areas:', ma.areas);
                            selectedLocations = ma.areas.map(area => {
                                const geoid = area.geoid || area.GEOID;
                                const blockId = area.blockId || area.BLOCK;
                                const tractId = area.tractId || area.TRACT;
                                const stateId = area.stateId || area.STATEFP;
                                const countyId = area.countyId || area.COUNTYFP;

                                let parsedData = {};
                                if (geoid && geoid.length === 15) {
                                    parsedData = {
                                        stateId: geoid.slice(0, 2),
                                        countyId: geoid.slice(2, 5),
                                        tractId: geoid.slice(5, 11),
                                        blockId: geoid.slice(11)
                                    };
                                }

                                return {
                                    id: geoid,
                                    type: 'block',
                                    blockId: blockId || parsedData.blockId,
                                    tractId: tractId || parsedData.tractId,
                                    stateId: stateId || parsedData.stateId,
                                    countyId: countyId || parsedData.countyId,
                                    geoid: geoid,
                                    population: area.population || area.POP100,
                                    GEOID: geoid,
                                    BLOCK: blockId || parsedData.blockId,
                                    TRACT: tractId || parsedData.tractId,
                                    STATEFP: stateId || parsedData.stateId,
                                    COUNTYFP: countyId || parsedData.countyId,
                                    POP100: area.population || area.POP100,
                                    name: `Block ${blockId || parsedData.blockId}, Tract ${tractId || parsedData.tractId}`,
                                    attributes: { ...area }
                                };
                            });
                            break;

                        case 'blockgroup':
                            console.log('[editMA] Processing block group areas:', ma.areas);
                            selectedLocations = ma.areas.map(area => {
                                const geoid = area.geoid || area.GEOID;
                                const blockGroupId = area.blockGroupId || area.BLKGRP;
                                const tractId = area.tractId || area.TRACT;
                                const stateId = area.stateId || area.STATEFP;
                                const countyId = area.countyId || area.COUNTYFP;

                                let parsedData = {};
                                if (geoid && geoid.length === 12) {
                                    parsedData = {
                                        stateId: geoid.slice(0, 2),
                                        countyId: geoid.slice(2, 5),
                                        tractId: geoid.slice(5, 11),
                                        blockGroupId: geoid.slice(11)
                                    };
                                }

                                return {
                                    id: geoid,
                                    type: 'blockgroup',
                                    blockGroupId: blockGroupId || parsedData.blockGroupId,
                                    tractId: tractId || parsedData.tractId,
                                    stateId: stateId || parsedData.stateId,
                                    countyId: countyId || parsedData.countyId,
                                    geoid: geoid,
                                    population: area.population || area.POP100,
                                    GEOID: geoid,
                                    BLKGRP: blockGroupId || parsedData.blockGroupId,
                                    TRACT: tractId || parsedData.tractId,
                                    STATEFP: stateId || parsedData.stateId,
                                    COUNTYFP: countyId || parsedData.countyId,
                                    POP100: area.population || area.POP100,
                                    name: `Block Group ${blockGroupId || parsedData.blockGroupId}, Tract ${tractId || parsedData.tractId}`,
                                    attributes: { ...area }
                                };
                            });
                            break;

                        // [Previous cases remain the same...]
                        case 'tract':
                            selectedLocations = ma.areas.map(area => ({
                                id: area.geoid || area.GEOID,
                                name: `Census Tract ${area.tractId || area.TRACT}`,
                                type: 'tract',
                                tractId: area.tractId || area.TRACT,
                                stateId: area.stateId || area.STATEFP,
                                countyId: area.countyId || area.COUNTYFP,
                                geoid: area.geoid || area.GEOID,
                                attributes: { ...area }
                            }));
                            break;

                        case 'place':
                            selectedLocations = ma.areas.map(area => ({
                                id: area.placeId,
                                name: area.name,
                                type: 'place',
                                placeId: area.placeId,
                                location: area.location,
                                placeData: {
                                    address: area.address,
                                    formattedAddress: area.formattedAddress
                                },
                                attributes: { ...area }
                            }));
                            break;

                        case 'zip':
                            selectedLocations = ma.areas.map(area => ({
                                id: area.code,
                                name: area.code,
                                type: 'zip',
                                attributes: { ...area }
                            }));
                            break;

                        case 'county':
                            selectedLocations = ma.areas.map(area => ({
                                id: area.fullName,
                                name: area.fullName,
                                type: 'county',
                                state: area.state,
                                fipsCode: area.fipsCode,
                                attributes: { ...area }
                            }));
                            break;

                        case 'drivetime':
                            selectedLocations = ma.areas.map(area => ({
                                id: `drivetime-${area.centerPoint.x}-${area.centerPoint.y}`,
                                name: `${area.minutes} Minute Drive Time`,
                                type: 'drivetime',
                                centerPoint: area.centerPoint,
                                minutes: area.minutes,
                                geometry: area.geometry,
                                attributes: { ...area }
                            }));

                            const driveTimeSection = document.getElementById('driveTimeSection');
                            if (driveTimeSection) {
                                driveTimeSection.style.display = 'block';
                            }
                            initializeDriveTimeControls();

                            if (selectedLocations.length > 0) {
                                updateSelectedDriveTime(
                                    selectedLocations[0].centerPoint,
                                    selectedLocations[0].minutes
                                );
                            }
                            break;

                        case 'radius':
                            selectedLocations = ma.areas.map(area => ({
                                id: `radius-${area.centerPoint.x}-${area.centerPoint.y}`,
                                name: `Radius Areas (${area.radiusValues.join(', ')} miles)`,
                                type: 'radius',
                                centerPoint: area.centerPoint,
                                radiusValues: area.radiusValues,
                                geometries: area.geometries,
                                attributes: { ...area }
                            }));

                            const radiusSection = document.getElementById('radiusSection');
                            if (radiusSection) {
                                radiusSection.style.display = 'block';
                            }
                            initializeRadius();

                            if (selectedLocations.length > 0) {
                                updateSelectedRadius(
                                    selectedLocations[0].centerPoint,
                                    selectedLocations[0].radiusValues
                                );
                            }
                            break;

                        case 'state':
                            selectedLocations = ma.areas.map(area => ({
                                id: area.id || area.name,
                                name: area.name,
                                type: 'state',
                                stateAbbr: area.stateAbbr,
                                fips: area.fips,
                                attributes: { ...area }
                            }));
                            break;

                        case 'cbsa':
                            selectedLocations = ma.areas.map(area => ({
                                id: area.cbsaId,
                                name: area.name,
                                type: 'cbsa',
                                cbsaType: area.cbsaType,
                                cbsaId: area.cbsaId,
                                csaId: area.csaId,
                                basename: area.basename,
                                attributes: { ...area }
                            }));
                            break;
                    }

                    console.log('[editMA] Converted selected locations:', selectedLocations);

                    // Update the location lists
                    updateLocationLists();

                    // Update type-specific fields visibility
                    toggleMATypeFields();

                    // Change the Save & Exit button to Update
                    const saveButton = document.querySelector('#ma-form .green-button');
                    saveButton.textContent = 'Update MA';
                    saveButton.setAttribute('data-ma-id', id);
                    saveButton.onclick = () => {
                        // Create maData object with all necessary data
                        const maData = {
                            type: ma.type,
                            name: document.getElementById('maName').value,
                            shortName: document.getElementById('shortName').value,
                            acs: document.getElementById('acsCheckbox').checked,
                            areas: selectedLocations,
                            fillColor: document.getElementById('fillColor').value,
                            borderColor: document.getElementById('borderColor').value,
                            transparency: parseInt(document.getElementById('transparency').value),
                            borderWeight: document.getElementById('noBorder').checked ? 0 : 
                                parseInt(document.getElementById('borderWeight').value),
                            visible: true
                        };
                        updateExistingMA(id, maData);
                    };

                    // Add the Remove MA button if it doesn't exist
                    const buttonRow = document.querySelector('#ma-form .button-row');
                    if (!buttonRow.querySelector('.remove-ma-button')) {
                        const removeButton = document.createElement('button');
                        removeButton.className = 'button remove-ma-button';
                        removeButton.textContent = 'Remove MA';
                        removeButton.onclick = () => removeMA(id);
                        buttonRow.insertBefore(removeButton, buttonRow.firstChild);
                    }

                } catch (error) {
                    console.error('[editMA] Error:', error);
                    alert('Error editing market area. Please try again.');
                }
            }


            let isEditingOrCreating = false;

            // Update initializeInteractiveOverlay function
            async function initializeInteractiveOverlay(maType) {
                if (!mapViewInstance) return;

                // Clear any existing graphics
                if (layers.highlightLayer) {
                    layers.highlightLayer.removeAll();
                }

                // Set edit mode flag
                isEditingOrCreating = true;

                // Remove existing handlers
                if (mapClickHandler) {
                    mapClickHandler.remove();
                    mapClickHandler = null;
                }
                if (mapMoveHandler) {
                    mapMoveHandler.remove();
                    mapMoveHandler = null;
                }

                // Add new click handler
                mapClickHandler = mapViewInstance.on("click", async (event) => {
                    const screenPoint = {
                        x: event.x,
                        y: event.y
                    };

                    const hitTestOptions = {
                        include: [layers.highlightLayer]
                    };

                    try {
                        const response = await mapViewInstance.hitTest(screenPoint, hitTestOptions);
                        const validResults = response.results.filter(result => 
                            result.graphic && 
                            result.graphic.attributes &&
                            result.graphic.layer === layers.highlightLayer
                        );

                        if (validResults.length > 0) {
                            const graphic = validResults[0].graphic;
                            const id = graphic.attributes.id;
                            const type = graphic.attributes.type;

                            // Check if the clicked feature matches the current market area type
                            if (type === document.getElementById('maType').value) {
                                if (selectedLocations.some(loc => loc.id === id || (loc.geoid && loc.geoid === id))) {
                                    moveLocationToAvailable(id);
                                } else {
                                    let locationData = {
                                        id: id,
                                        name: id,
                                        type: type
                                    };

                                    // Add additional data for census tracts
                                    if (type === 'tract') {
                                        locationData = {
                                            ...locationData,
                                            geoid: id,
                                            tractId: graphic.attributes.TRACT || id.slice(-6),
                                            stateId: graphic.attributes.STATE || id.slice(0, 2),
                                            countyId: graphic.attributes.COUNTY || id.slice(2, 5)
                                        };
                                    }

                                    moveLocationToSelected(locationData);
                                }
                            }
                        }
                    } catch (err) {
                        console.error('Error in hit test:', err);
                    }
                });

                // Add movement handler for hover effects
                mapMoveHandler = mapViewInstance.on("pointer-move", (event) => {
                    const screenPoint = {
                        x: event.x,
                        y: event.y
                    };

                    mapViewInstance.hitTest(screenPoint, { include: [layers.highlightLayer] })
                        .then(response => {
                            const validResults = response.results.filter(result => 
                                result.graphic && 
                                result.graphic.attributes &&
                                result.graphic.layer === layers.highlightLayer
                            );

                            mapViewInstance.container.style.cursor = validResults.length > 0 ? 'pointer' : 'default';
                        });
                });

                // Add drag handler for pan operations
                mapViewInstance.navigation.mouseWheelZoomEnabled = true;
                mapViewInstance.navigation.browserTouchPanEnabled = true;

                // Watch for extent changes during editing
                mapViewInstance.watch('extent', debounce(() => {
                    if (isEditingOrCreating) {
                        updateOverlay(true);
                    }
                }, 300));

                // Initial update of the overlay
                await updateOverlay(true, maType);
            }


            function moveLocationToSelected(location) {
                console.log('[moveLocationToSelected] Starting with location:', location);

                if (location.type === 'block') {
                    // Get attributes from the feature or response
                    const blockAttrs = location.attributes || location;
                    console.log('[moveLocationToSelected] Working with block attributes:', blockAttrs);

                    // Parse GEOID to extract components if they're not directly available
                    const geoid = blockAttrs.GEOID || blockAttrs.id;
                    let blockId = blockAttrs.BLOCK;
                    let tractId = blockAttrs.TRACT;
                    let stateId = blockAttrs.STATEFP;
                    let countyId = blockAttrs.COUNTYFP;

                    // If we don't have the components but have GEOID, parse it
                    if (geoid && (!blockId || !tractId || !stateId || !countyId)) {
                        if (geoid.length === 15) {
                            stateId = geoid.slice(0, 2);
                            countyId = geoid.slice(2, 5);
                            tractId = geoid.slice(5, 11);
                            blockId = geoid.slice(11);
                        }
                    }

                    // Build the block data object
                    const blockData = {
                        id: geoid,
                        type: 'block',
                        blockId: blockId,
                        tractId: tractId,
                        stateId: stateId,
                        countyId: countyId,
                        geoid: geoid,
                        population: blockAttrs.POP100,
                        name: `Block ${blockId}, Tract ${tractId}`,
                        // Store all original attributes
                        BLOCK: blockId,
                        TRACT: tractId,
                        GEOID: geoid,
                        STATEFP: stateId,
                        COUNTYFP: countyId,
                        POP100: blockAttrs.POP100,
                        attributes: blockAttrs
                    };

                    console.log('[moveLocationToSelected] Processed block data:', blockData);

                    // Check if block already exists in selected locations
                    const existingLocation = selectedLocations.some(loc => loc.geoid === blockData.geoid);

                    if (!existingLocation) {
                        console.log('[moveLocationToSelected] Adding new block to selection:', blockData);
                        // Remove from available if present
                        availableLocations = availableLocations.filter(loc => loc.geoid !== blockData.geoid);
                        // Add to selected locations
                        selectedLocations.push(blockData);
                    } else {
                        console.log('[moveLocationToSelected] Block already in selected locations:', blockData.geoid);
                    }
                } else {
                    // Handle other location types as before
                    const existingLocation = selectedLocations.some(loc => loc.id === location.id);
                    if (!existingLocation) {
                        availableLocations = availableLocations.filter(loc => loc.id !== location.id);
                        selectedLocations.push(location);
                    }
                }

                // Update displays
                updateLocationLists();
                updateOverlay(true);
            }

            // Update the moveLocationToAvailable function to handle blocks properly
            function moveLocationToAvailable(locationId) {
                console.log('[moveLocationToAvailable] Moving location to available:', locationId);
                
                // Find the location in selectedLocations
                const selectedIndex = selectedLocations.findIndex(loc => {
                    if (loc.type === 'block') {
                        return loc.geoid === locationId || loc.id === locationId;
                    }
                    return loc.id === locationId;
                });

                if (selectedIndex !== -1) {
                    const location = selectedLocations[selectedIndex];
                    selectedLocations.splice(selectedIndex, 1);
                    
                    // Only add to available if not already present
                    const existingInAvailable = availableLocations.some(loc => {
                        if (location.type === 'block') {
                            return loc.geoid === location.geoid || loc.id === location.id;
                        }
                        return loc.id === location.id;
                    });

                    if (!existingInAvailable) {
                        availableLocations.push(location);
                    }
                    
                    updateLocationLists();
                    updateOverlay(true);
                }
            }

            function handleMapClick(event) {
                console.log('[handleMapClick] Map clicked at:', event.mapPoint);

                mapViewInstance.hitTest(event).then(response => {
                    const validResults = response.results.filter(result => 
                        result.graphic && 
                        result.graphic.attributes &&
                        result.graphic.layer === layers.highlightLayer
                    );

                    if (validResults.length === 0) {
                        console.log('[handleMapClick] No valid features found at click location');
                        return;
                    }

                    const graphic = validResults[0].graphic;
                    const attrs = graphic.attributes;
                    const maType = document.getElementById('maType').value;

                    console.log('[handleMapClick] Feature found:', {
                        attributes: attrs,
                        type: maType,
                        graphic: graphic
                    });

                    if (attrs.type !== maType) {
                        console.log('[handleMapClick] Feature type mismatch:', {
                            featureType: attrs.type,
                            expectedType: maType
                        });
                        return;
                    }

                    let locationData;
                    switch(maType) {
                        case 'block':
                            // Extract block information from feature
                            locationData = {
                                id: attrs.GEOID,
                                name: `Block ${attrs.BLOCK}, Tract ${attrs.TRACT}`,
                                type: 'block',
                                blockId: attrs.BLOCK,
                                tractId: attrs.TRACT,
                                stateId: attrs.STATEFP,
                                countyId: attrs.COUNTYFP,
                                geoid: attrs.GEOID,
                                population: attrs.POP100,
                                // Include original Census identifiers
                                BLOCK: attrs.BLOCK,
                                TRACT: attrs.TRACT,
                                GEOID: attrs.GEOID,
                                STATEFP: attrs.STATEFP,
                                COUNTYFP: attrs.COUNTYFP,
                                POP100: attrs.POP100,
                                // Include full attributes
                                attributes: {
                                    ...attrs,
                                    type: 'block' // Ensure type is preserved
                                },
                                // Store the geometry if available
                                geometry: graphic.geometry
                            };

                            // If we have a GEOID but missing components, parse them
                            if (locationData.geoid && (!locationData.blockId || !locationData.tractId)) {
                                const geoid = locationData.geoid;
                                if (geoid.length === 15) {
                                    locationData.stateId = geoid.slice(0, 2);
                                    locationData.countyId = geoid.slice(2, 5);
                                    locationData.tractId = geoid.slice(5, 11);
                                    locationData.blockId = geoid.slice(11);
                                    locationData.name = `Block ${locationData.blockId}, Tract ${locationData.tractId}`;
                                }
                            }
                            break;

                        case 'blockgroup':
                            locationData = {
                                id: attrs.GEOID,
                                name: `Block Group ${attrs.BLKGRP}, Tract ${attrs.TRACT}`,
                                type: 'blockgroup',
                                blockGroupId: attrs.BLKGRP,
                                tractId: attrs.TRACT,
                                stateId: attrs.STATEFP,
                                countyId: attrs.COUNTYFP,
                                geoid: attrs.GEOID,
                                population: attrs.POP100,
                                attributes: attrs,
                                geometry: graphic.geometry
                            };
                            break;

                        case 'tract':
                            locationData = {
                                id: attrs.GEOID20 || attrs.GEOID,
                                name: `Census Tract ${attrs.TRACTCE20 || attrs.TRACT}`,
                                type: 'tract',
                                tractId: attrs.TRACTCE20 || attrs.TRACT,
                                stateId: attrs.STATEFP20 || attrs.STATEFP,
                                countyId: attrs.COUNTYFP20 || attrs.COUNTYFP,
                                geoid: attrs.GEOID20 || attrs.GEOID,
                                attributes: attrs,
                                geometry: graphic.geometry
                            };
                            break;

                        case 'place':
                            locationData = {
                                id: attrs.GEOID,
                                name: attrs.NAME,
                                type: 'place',
                                placeId: attrs.PLACEFP,
                                geoid: attrs.GEOID,
                                state: attrs.STATE_NAME,
                                attributes: attrs,
                                geometry: graphic.geometry
                            };
                            break;

                        case 'zip':
                            locationData = {
                                id: attrs.ZIP || attrs.id,
                                name: attrs.ZIP || attrs.id,
                                type: 'zip',
                                code: attrs.ZIP || attrs.id,
                                attributes: attrs,
                                geometry: graphic.geometry
                            };
                            break;

                        case 'county':
                            locationData = {
                                id: `${attrs.NAME}, ${attrs.STATE_NAME}`,
                                name: `${attrs.NAME}, ${attrs.STATE_NAME}`,
                                fullName: `${attrs.NAME}, ${attrs.STATE_NAME}`,
                                type: 'county',
                                state: attrs.STATE_NAME,
                                attributes: attrs,
                                geometry: graphic.geometry
                            };
                            break;

                        case 'drivetime':
                            locationData = {
                                id: `drivetime-${attrs.centerPoint.x}-${attrs.centerPoint.y}`,
                                name: `${attrs.minutes} Minute Drive Time`,
                                type: 'drivetime',
                                centerPoint: attrs.centerPoint,
                                minutes: attrs.minutes,
                                geometry: attrs.geometry,
                                attributes: attrs
                            };
                            break;

                        case 'radius':
                            locationData = {
                                id: `radius-${attrs.centerPoint.x}-${attrs.centerPoint.y}`,
                                name: `Radius Areas (${attrs.radiusValues.join(', ')} miles)`,
                                type: 'radius',
                                centerPoint: attrs.centerPoint,
                                radiusValues: attrs.radiusValues,
                                geometries: attrs.geometries,
                                attributes: attrs
                            };
                            break;

                        case 'state':
                            locationData = {
                                id: attrs.STATE_NAME,
                                name: attrs.STATE_NAME,
                                type: 'state',
                                stateAbbr: attrs.STATE_ABBR,
                                fips: attrs.STATE_FIPS,
                                attributes: attrs,
                                geometry: graphic.geometry
                            };
                            break;

                        case 'cbsa':
                            locationData = {
                                id: attrs.CBSAFP || attrs.GEOID,
                                name: attrs.NAME,
                                type: 'cbsa',
                                cbsaType: attrs.MEMI === '1' ? 'metro' : 'micro',
                                cbsaId: attrs.CBSAFP || attrs.GEOID,
                                csaId: attrs.CSA,
                                basename: attrs.BASENAME,
                                attributes: attrs,
                                geometry: graphic.geometry
                            };
                            break;

                        default:
                            console.warn('[handleMapClick] Unhandled market area type:', maType);
                            return;
                    }

                    // Ensure we have valid location data
                    if (!locationData || !locationData.id) {
                        console.error('[handleMapClick] Failed to create valid location data:', {
                            locationData,
                            originalAttrs: attrs
                        });
                        return;
                    }

                    console.log('[handleMapClick] Processed location data:', locationData);

                    // Check if the location is already selected
                    const isSelected = selectedLocations.some(loc => {
                        if (maType === 'block') {
                            return loc.geoid === locationData.geoid || 
                                loc.id === locationData.id ||
                                loc.GEOID === locationData.GEOID;
                        } else if (['blockgroup', 'tract'].includes(maType)) {
                            return loc.geoid === locationData.geoid || 
                                loc.id === locationData.id;
                        }
                        return loc.id === locationData.id;
                    });

                    console.log('[handleMapClick] Selection status:', {
                        isSelected: isSelected,
                        locationId: locationData.id,
                        selectedCount: selectedLocations.length
                    });

                    // Toggle selection
                    if (isSelected) {
                        console.log('[handleMapClick] Removing from selection:', locationData.id);
                        moveLocationToAvailable(locationData.id);
                    } else {
                        console.log('[handleMapClick] Adding to selection:', locationData);
                        moveLocationToSelected(locationData);
                    }

                    // Update the overlay to reflect changes
                    updateOverlay(true).catch(error => {
                        console.error('[handleMapClick] Error updating overlay:', error);
                    });

                }).catch(error => {
                    console.error('[handleMapClick] Error processing click:', error);
                });
            }

            // Update the event listeners for location movement
            function setupLocationMovementListeners() {
                const transferButtons = document.querySelectorAll('.entries-section .button');
                transferButtons.forEach(button => {
                    button.addEventListener('click', function(e) {
                        const direction = e.target.textContent.includes('→') ? 'right' : 'left';
                        moveSelectedLocations(direction);
                    });
                });
            }

            function moveSelectedLocations(direction) {
                if (!mapViewInstance || !layers.highlightLayer) return;

                require([
                    "esri/Graphic",
                    "esri/geometry/geometryEngine"
                ], function(Graphic, geometryEngine) {
                    const maType = document.getElementById('maType').value;

                    if (direction === 'right') {
                        // Move from available to selected
                        const selectedCheckboxes = document.querySelectorAll('#availableLocations input:checked');
                        selectedCheckboxes.forEach(checkbox => {
                            const locationItem = checkbox.closest('.location-item');
                            const locationId = locationItem.dataset.id;
                            const location = availableLocations.find(loc => loc.id === locationId);
                            
                            if (location) {
                                // Add to selected locations
                                selectedLocations.push(location);
                                availableLocations = availableLocations.filter(loc => loc.id !== locationId);

                                // Update map visualization - highlight the selected area
                                const features = layers.highlightLayer.graphics.filter(g => 
                                    g.attributes?.id === locationId || 
                                    (location.type === 'tract' && g.attributes?.id === location.geoid)
                                );

                                features.forEach(feature => {
                                    // Create new graphic with proper highlighted selected styling
                                    const newGraphic = new Graphic({
                                        geometry: feature.geometry,
                                        symbol: {
                                            type: "simple-fill",
                                            color: [0, 255, 0, 0.3],  // Highlighted green with 30% opacity
                                            outline: {
                                                color: [0, 255, 0, 1], // Solid green outline
                                                width: 2
                                            }
                                        },
                                        attributes: {
                                            ...feature.attributes,
                                            isSelected: true
                                        }
                                    });

                                    // Replace old graphic with new one
                                    layers.highlightLayer.remove(feature);
                                    layers.highlightLayer.add(newGraphic);
                                });
                            }
                        });
                    } else {
                        // Move from selected to available
                        const selectedCheckboxes = document.querySelectorAll('#selectedLocations input:checked');
                        selectedCheckboxes.forEach(checkbox => {
                            const locationItem = checkbox.closest('.location-item');
                            const locationId = locationItem.dataset.id;
                            const location = selectedLocations.find(loc => loc.id === locationId);
                            
                            if (location) {
                                // Add to available locations
                                availableLocations.push(location);
                                selectedLocations = selectedLocations.filter(loc => loc.id !== locationId);

                                // Update map visualization - return to default gray style
                                const features = layers.highlightLayer.graphics.filter(g => 
                                    g.attributes?.id === locationId || 
                                    (location.type === 'tract' && g.attributes?.id === location.geoid)
                                );

                                features.forEach(feature => {
                                    // Create new graphic with default unselected styling
                                    const newGraphic = new Graphic({
                                        geometry: feature.geometry,
                                        symbol: {
                                            type: "simple-fill",
                                            color: [200, 200, 200, 0.1],  // Light gray fill
                                            outline: {
                                                color: [128, 128, 128, 0.5], // Gray outline
                                                width: 1
                                            }
                                        },
                                        attributes: {
                                            ...feature.attributes,
                                            isSelected: false
                                        }
                                    });

                                    // Replace old graphic with new one
                                    layers.highlightLayer.remove(feature);
                                    layers.highlightLayer.add(newGraphic);
                                });
                            }
                        });
                    }

                    // Update the lists
                    updateLocationLists();

                    // Update any counter or UI elements
                    const selectedLocationsCount = document.getElementById('selectedLocationsCount');
                    if (selectedLocationsCount) {
                        selectedLocationsCount.textContent = `(${selectedLocations.length} selected)`;
                    }

                    // Uncheck "Select All" checkboxes
                    const selectAllAvailable = document.getElementById('selectAllAvailableLocations');
                    const selectAllSelected = document.getElementById('selectAllSelectedLocations');
                    if (selectAllAvailable) selectAllAvailable.checked = false;
                    if (selectAllSelected) selectAllSelected.checked = false;
                });
            }

            function handleMapHover(event) {
                mapViewInstance.hitTest(event).then(response => {
                    const graphic = response.results[0]?.graphic;
                    
                    // Update cursor based on whether we're hovering over a selectable feature
                    if (graphic && graphic.attributes && 
                        graphic.attributes.type === document.getElementById('maType').value) {
                        mapViewInstance.container.style.cursor = 'pointer';
                    } else {
                        mapViewInstance.container.style.cursor = 'default';
                    }
                });
            }

            // Update hexToRGBA to return proper color array
            function hexToRGBA(hex, alpha = 1) {
                try {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    return [r, g, b, alpha];
                } catch (error) {
                    console.error("Error converting hex to RGBA:", error);
                    return [255, 0, 0, alpha]; // Default to red
                }
            }
        
            // Function to show export status
            function showExportStatus(show = true, text = 'Exporting data...', subtext = 'This may take a few minutes') {
                const statusIndicator = document.getElementById('exportStatusIndicator');
                if (!statusIndicator) {
                    document.body.insertAdjacentHTML('beforeend', statusHtml);
                }
                
                const indicator = document.getElementById('exportStatusIndicator');
                const statusText = document.getElementById('exportStatusText');
                const statusSubtext = document.getElementById('exportStatusSubtext');
                
                if (show) {
                    statusText.textContent = text;
                    statusSubtext.textContent = subtext;
                    indicator.style.display = 'block';
                } else {
                    indicator.style.display = 'none';
                }
            }


            // Update close dialog function to handle in-progress exports
            function closeExportDialog() {
                const dialog = document.getElementById('exportDialog');
                if (dialog) {
                    dialog.style.display = 'none';
                    
                    // Clear search
                    const searchInput = document.getElementById('variableSearch');
                    if (searchInput) searchInput.value = '';
                    
                    // Reset select all checkboxes
                    const selectAllAvailable = document.getElementById('selectAllAvailable');
                    const selectAllSelected = document.getElementById('selectAllSelected');
                    if (selectAllAvailable) selectAllAvailable.checked = false;
                    if (selectAllSelected) selectAllSelected.checked = false;
                }
            }



            // Add this helper function if you don't already have it
            function fallbackDownload(blob, filename) {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            }

            // Helper function for enriching zip codes
            async function enrichZipCodes(zipCodes, variables, maName) {
                const study_areas = [{
                    sourceCountry: "USA",
                    layer: "US.ZIP5",
                    ids: zipCodes
                }];

                try {
                    // Split variables into chunks
                    const variableChunks = [];
                    for (let i = 0; i < variables.length; i += 50) {
                        variableChunks.push(variables.slice(i, i + 50));
                    }

                    let combinedData = {};
                    
                    // Process each chunk
                    for (const chunk of variableChunks) {
                        const response = await fetch('/enrich-data', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                study_areas: study_areas,
                                variables: chunk
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`Enrichment request failed: ${response.statusText}`);
                        }

                        const chunkData = await response.json();
                        if (!chunkData.success) {
                            throw new Error(chunkData.error || 'Enrichment failed');
                        }

                        // Combine data from this chunk
                        combinedData = { ...combinedData, ...chunkData.data };
                    }

                    // Add metadata
                    return {
                        ...combinedData,
                        zipCodes: zipCodes.join(', '),
                        totalZipCodes: zipCodes.length
                    };

                } catch (error) {
                    console.error(`Error enriching zip codes for ${maName}:`, error);
                    throw error;
                }
            }

            // Helper function for enriching counties
            async function enrichCounties(counties, variables, maName) {
                const study_areas = counties.map(county => ({
                    sourceCountry: "USA",
                    layer: "US.Counties",
                    ids: [`${county.name}, ${county.state}`]
                }));

                try {
                    // Split variables into chunks
                    const variableChunks = [];
                    for (let i = 0; i < variables.length; i += 50) {
                        variableChunks.push(variables.slice(i, i + 50));
                    }

                    let combinedData = {};
                    
                    // Process each chunk
                    for (const chunk of variableChunks) {
                        const response = await fetch('/enrich-data', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                study_areas: study_areas,
                                variables: chunk
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`Enrichment request failed: ${response.statusText}`);
                        }

                        const chunkData = await response.json();
                        if (!chunkData.success) {
                            throw new Error(chunkData.error || 'Enrichment failed');
                        }

                        // Combine data from this chunk
                        combinedData = { ...combinedData, ...chunkData.data };
                    }

                    // Add metadata
                    return {
                        ...combinedData,
                        counties: counties.map(c => `${c.name}, ${c.state}`).join('; '),
                        totalCounties: counties.length
                    };

                } catch (error) {
                    console.error(`Error enriching counties for ${maName}:`, error);
                    throw error;
                }
            }

            // Helper function to combine enrichment data from multiple chunks
            function combineEnrichmentData(dataChunks, maName) {
                // Initialize the combined data object
                const combinedData = {
                    marketArea: maName,
                    numericalData: {},
                    metadata: {}
                };
                
                // Process each chunk
                dataChunks.forEach((chunk, index) => {
                    if (!chunk || !chunk.data) {
                        console.warn(`Empty or invalid chunk at index ${index}`);
                        return;
                    }
                    
                    Object.entries(chunk.data).forEach(([key, value]) => {
                        // Check if the value is numerical
                        if (typeof value === 'number' && !isNaN(value)) {
                            // Sum numerical values
                            if (combinedData.numericalData[key] === undefined) {
                                combinedData.numericalData[key] = 0;
                            }
                            combinedData.numericalData[key] += value;
                        } else {
                            // Store non-numerical values in metadata
                            if (!combinedData.metadata[key]) {
                                combinedData.metadata[key] = value;
                            }
                        }
                    });
                });

                // Flatten the structure for Excel export
                const flattenedData = {
                    marketArea: maName,
                    ...combinedData.numericalData,
                    ...combinedData.metadata
                };

                return flattenedData;
            }
            async function enrichMarketAreas() {
                try {
                    const exportButton = document.querySelector('.export-button');
                    const originalText = exportButton.textContent;
                    exportButton.disabled = true;
                    exportButton.textContent = 'Exporting...';

                    // Get visible market areas
                    const visibleAreas = marketAreas.filter(ma => ma.visible);
                    console.log('Processing market areas:', visibleAreas);

                    if (visibleAreas.length === 0) {
                        alert('No market areas to export. Please create at least one market area and ensure it is visible.');
                        return;
                    }

                    // First get the JSON data
                    const jsonResponse = await fetch('/enrich-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            study_areas: visibleAreas,
                            exportType: 'json'
                        })
                    });

                    if (!jsonResponse.ok) {
                        throw new Error(`HTTP error! status: ${jsonResponse.status}`);
                    }

                    const jsonResult = await jsonResponse.json();
                    if (!jsonResult.success) {
                        throw new Error(jsonResult.error || 'Enrichment failed');
                    }

                    // Now get the Excel file
                    const excelResponse = await fetch('/enrich-data', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            study_areas: visibleAreas,
                            exportType: 'excel'
                        })
                    });

                    if (!excelResponse.ok) {
                        throw new Error(`HTTP error! status: ${excelResponse.status}`);
                    }

                    // Get the filename from the Content-Disposition header if available
                    const contentDisposition = excelResponse.headers.get('Content-Disposition');
                    let filename = 'market_areas_analysis.xlsx';
                    if (contentDisposition) {
                        const matches = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/.exec(contentDisposition);
                        if (matches != null && matches[1]) {
                            filename = matches[1].replace(/['"]/g, '');
                        }
                    }

                    // Convert response to blob and download
                    const blob = await excelResponse.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);

                    alert('Export completed successfully!');

                } catch (error) {
                    console.error('Enrichment error:', error);
                    alert(`Error during export: ${error.message}`);
                } finally {
                    const exportButton = document.querySelector('.export-button');
                    if (exportButton) {
                        exportButton.disabled = false;
                        exportButton.textContent = 'Export Data';
                    }
                }
            }

            // Update the way county names are processed
            function processCountyName(area) {
                let countyName, stateName;
                
                if (area.fullName) {
                    const cleanedName = cleanCountyName(area.fullName);
                    const parts = cleanedName.split(',').map(part => part.trim());
                    countyName = parts[0];
                    stateName = parts[1];
                } else {
                    countyName = area.name;
                    stateName = area.state;
                }
                
                return { countyName, stateName };
            }

            // Helper function to clean county name
            function cleanCountyName(name) {
                return name
                    .replace(/\s*,\s*California,\s*California$/, ', California')  // Remove duplicate state
                    .replace(/\s+County(?=\s*,|\s*$)/i, '')  // Remove 'County' before comma or end
                    .trim();
            }

            // Update getFipsCode function to handle URLs and state formatting correctly
            async function getFipsCode(countyName, state) {
                try {
                    // Clean up county name - remove any trailing "County"
                    const cleanCounty = countyName.replace(/\s+County$/i, '').trim();
                    
                    // Clean up state - remove any duplicates and extra spaces
                    let cleanState = state.split(',')[0].trim();
                    
                    // Log the cleaned values
                    console.log(`Looking up FIPS for: ${cleanCounty}, ${cleanState}`);
                    
                    // Make request to local endpoint
                    const response = await fetch('/get_county_fips', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            county: cleanCounty,
                            state: cleanState
                        })
                    });

                    if (!response.ok) {
                        console.error(`FIPS lookup failed with status: ${response.status}`);
                        return null;
                    }

                    const data = await response.json();
                    
                    if (data.success && data.fips) {
                        console.log(`Found FIPS code: ${data.fips} for ${cleanCounty}, ${cleanState}`);
                        return data.fips;
                    }
                    
                    console.warn(`No FIPS code found for ${cleanCounty}, ${cleanState}`);
                    return null;
                } catch (error) {
                    console.error('Error in FIPS lookup:', error);
                    return null;
                }
            }

            // Helper function to parse county info
            function parseCountyInfo(area) {
                try {
                    let countyName, stateName;
                    
                    if (area.fullName) {
                        // Split by comma and clean
                        const parts = area.fullName.split(',').map(part => part.trim());
                        
                        if (parts.length >= 2) {
                            countyName = parts[0];
                            // Take only the first state reference
                            stateName = parts[1].split(',')[0].trim();
                        } else {
                            throw new Error(`Invalid county format: ${area.fullName}`);
                        }
                    } else {
                        countyName = area.name;
                        stateName = area.state;
                    }

                    // Clean up county name
                    countyName = countyName.replace(/\s+County$/i, '').trim();

                    // Clean up state name (remove any duplicates)
                    stateName = stateName.split(',')[0].trim();

                    console.log(`Parsed county info: ${countyName}, ${stateName}`);
                    return { countyName, stateName };
                } catch (error) {
                    console.error('Error parsing county info:', error);
                    return { countyName: area.name, stateName: area.state };
                }
            }
            
            // Add batch FIPS lookup utility
            async function batchGetFIPSCodes(counties) {
                try {
                    const response = await fetch('/batch_county_fips', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ counties })
                    });

                    const data = await response.json();
                    return data.success ? data.results : {};
                } catch (error) {
                    console.error('Error in batch FIPS lookup:', error);
                    return {};
                }
            }

            // Function to create MA list item
            function createMAListItem(ma) {
                const maItem = document.createElement('div');
                maItem.className = 'ma-item';
                maItem.dataset.id = ma.id;

                const content = document.createElement('div');
                content.className = 'ma-content';
                content.style.display = 'flex';
                content.style.alignItems = 'center';
                content.style.width = '100%';

                // Add drag handle
                const dragHandle = document.createElement('span');
                dragHandle.innerHTML = '⋮⋮';
                dragHandle.style.cursor = 'move';
                dragHandle.style.marginRight = '10px';
                dragHandle.style.color = '#666';

                // Add visibility toggle
                const visibilityBtn = document.createElement('button');
                visibilityBtn.className = 'visibility-toggle';
                visibilityBtn.innerHTML = ma.visible ? '👁️' : '👁️‍🗨️';
                visibilityBtn.onclick = () => toggleMAVisibility(ma.id);

                // Add name and type
                const nameSpan = document.createElement('span');
                nameSpan.className = 'ma-name';
                nameSpan.textContent = `${ma.name} (${ma.type.toUpperCase()})`;

                // Add edit button
                const editBtn = document.createElement('button');
                editBtn.className = 'edit-button';
                editBtn.innerHTML = '⚙️';
                editBtn.onclick = () => editMA(ma.id);

                // Assemble the content
                content.appendChild(dragHandle);
                content.appendChild(visibilityBtn);
                content.appendChild(nameSpan);
                content.appendChild(editBtn);
                maItem.appendChild(content);

                return maItem;
            }
            // Debug helper
            function debugCountyData(area) {
                console.log('County Area Data:', {
                    fullName: area.fullName,
                    name: area.name,
                    state: area.state,
                    parsed: parseCountyInfo(area)
                });
            }
            // Function to update FIPS display in UI
            function updateMAFipsDisplay(maItem, fipsCode) {
                if (!maItem || !fipsCode) return;
                
                const nameSpan = maItem.querySelector('.ma-name');
                if (!nameSpan) return;
                
                let fipsSpan = maItem.querySelector('.ma-fips');
                if (!fipsSpan) {
                    fipsSpan = document.createElement('span');
                    fipsSpan.className = 'ma-fips';
                    fipsSpan.style.marginLeft = '10px';
                    fipsSpan.style.color = '#666';
                    nameSpan.appendChild(fipsSpan);
                }
                
            }   
            // Helper function to get state from full county name
            function getStateFromFullName(fullName) {
                if (!fullName) return null;
                const parts = fullName.split(',');
                return parts.length > 1 ? parts[1].trim() : null;
            }


            // Modified export functions
            function exportDefs() {
                if (marketAreas.length === 0) {
                    alert("No market areas defined. Please create at least one market area before exporting.");
                    return;
                }
                showExportDialog();
            }
            // Function to format market areas data for export with variables as rows
            function formatMarketAreasForExport(selectedMarketAreas) {
                // Transform market areas into columnar format
                const marketAreaColumns = selectedMarketAreas.map(ma => {
                    // Process each market area
                    let maData = {
                        fullName: ma.name,
                        shortName: ma.shortName || '',
                        definitionType: ma.type === 'zip' ? 'ZCTA' : ma.type.toUpperCase(),
                        state: '',
                        county: '',
                        areaIncluded: '',
                        fips: '',  // Added FIPS field
                        notes: ma.notes || '',
                        definitionVintage: new Date().getFullYear().toString()
                    };

                    // Process areas based on type
                    if (ma.type === 'zip') {
                        if (ma.areas && ma.areas.length > 0) {
                            maData.areaIncluded = ma.areas.map(area => area.code).join(', ');
                            // No FIPS for zip codes
                            maData.fips = '';
                        }
                    } else if (ma.type === 'county') {
                        if (ma.areas && ma.areas.length > 0) {
                            const area = ma.areas[0];
                            if (area.fullName) {
                                const parts = area.fullName.split(', ');
                                if (parts.length === 2) {
                                    // Format county name properly with "County"
                                    let countyName = parts[0];
                                    if (!countyName.toLowerCase().includes('county')) {
                                        countyName += ' County';
                                    }
                                    maData.county = countyName;
                                    maData.state = getStateFullName(parts[1]); // Use full state name
                                    maData.areaIncluded = countyName + ', ' + maData.state;
                                }
                            } else {
                                maData.county = area.name + ' County';
                                maData.state = getStateFullName(area.state);
                                maData.areaIncluded = maData.county + ', ' + maData.state;
                            }
                            // Include FIPS code if available
                            maData.fips = area.fipsCode || '';
                        }

                        // Update definition for multiple counties
                        if (ma.areas.length > 1) {
                            maData.areaIncluded = ma.areas.map(county => {
                                const name = county.fullName ? 
                                    county.fullName.split(',')[0] : 
                                    county.name;
                                const state = county.fullName ? 
                                    county.fullName.split(',')[1].trim() : 
                                    county.state;
                                const formattedName = name.includes('County') ? name : `${name} County`;
                                return `${formattedName}, ${getStateFullName(state)}`;
                            }).join('; ');
                        }
                    }

                    return maData;
                });

                // Define all the variable rows we want to include
                const variableRows = [
                    { name: 'Market Area Name', key: 'fullName' },
                    { name: 'Short Name', key: 'shortName' },
                    { name: 'Definition Type', key: 'definitionType' },
                    { name: 'Areas Included', key: 'areaIncluded' },
                    { name: 'FIPS', key: 'fips' },
                    { name: 'State', key: 'state' },
                    { name: 'County', key: 'county' },
                    { name: 'Notes', key: 'notes' },
                    { name: 'Definition Vintage', key: 'definitionVintage' }
                ];

                // Create the transposed structure
                const transposedData = {
                    variableRows: variableRows.map(varRow => ({
                        variableName: varRow.name,
                        values: marketAreaColumns.map(maCol => maCol[varRow.key] || '')
                    }))
                };

                return transposedData;
            }



            function exportJPEG() {
                if (!mapViewInstance) {
                    alert("Map is not initialized. Please wait for the map to load.");
                    return;
                }
        
                mapViewInstance.takeScreenshot({ format: "jpg" }).then(function(screenshot) {
                    var link = document.createElement("a");
                    link.download = "map_screenshot.jpg";
                    link.href = screenshot.dataUrl;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                }).catch(function(error) {
                    console.error("Error taking screenshot:", error);
                    alert("An error occurred while exporting the JPEG. Please try again.");
                });
            }
        
            function exportMxd() {
                alert("MXD export functionality not implemented yet.");
            }
        
            function bulkImportMAs() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = function(event) {
                    const file = event.target.files[0];
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedMAs = JSON.parse(e.target.result);
                            if (Array.isArray(importedMAs)) {
                                importedMAs.forEach(ma => {
                                    ma.id = marketAreas.length + 1;
                                    ma.order = marketAreas.length;
                                    marketAreas.push(ma);
                                });
                                updateMAList();
                                updateMap();
                                alert(`Successfully imported ${importedMAs.length} Market Areas.`);
                            } else {
                                throw new Error('Invalid file format. Expected an array of Market Areas.');
                            }
                        } catch (error) {
                            console.error('Error parsing imported file:', error);
                            alert('Error importing Market Areas. Please check the file format and try again.');
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            }
        
            function toggleBorderWeight() {
                const noBorder = document.getElementById('noBorder').checked;
                const borderWeightInput = document.getElementById('borderWeight');
                borderWeightInput.disabled = noBorder;
                if (noBorder) {
                    borderWeightInput.value = 0;
                } else {
                    borderWeightInput.value = 1;
                }
            }
        
            function setupSearchFunctionality() {
                const searchInput = document.getElementById('searchInput');
                const searchResults = document.getElementById('searchResults');
                const clearSearch = document.getElementById('clearSearch');

                if (!searchInput || !searchResults || !clearSearch) {
                    console.error('Search elements not found');
                    return;
                }

                // Add event listener for input changes
                searchInput.addEventListener('input', debounce(async (event) => {
                    const query = event.target.value.trim();
                    clearSearch.style.display = query ? 'block' : 'none';

                    if (query.length >= 2) {
                        try {
                            const suggestions = await getSuggestions(query);
                            displaySearchResults(suggestions);
                        } catch (error) {
                            console.error('Error getting suggestions:', error);
                            searchResults.style.display = 'none';
                        }
                    } else {
                        searchResults.style.display = 'none';
                    }
                }, 300));

                // Clear button handler
                clearSearch.addEventListener('click', () => {
                    searchInput.value = '';
                    searchResults.innerHTML = '';
                    searchResults.style.display = 'none';
                    clearSearch.style.display = 'none';
                    searchInput.focus();
                });

                // Click outside handler
                document.addEventListener('click', (event) => {
                    if (!searchInput.contains(event.target) && !searchResults.contains(event.target)) {
                        searchResults.style.display = 'none';
                    }
                });
            }

            async function getSuggestions(query) {
                const url = "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/suggest";
                const params = {
                    f: "json",
                    text: query,
                    maxSuggestions: 5,
                    countryCode: "USA",
                    categories: "Address,Postal,Populated Place,State or Province,County"
                };

                const queryString = Object.entries(params)
                    .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
                    .join('&');

                try {
                    const response = await fetch(`${url}?${queryString}`);
                    const data = await response.json();
                    return data.suggestions || [];
                } catch (error) {
                    console.error('Error fetching suggestions:', error);
                    return [];
                }
            }            
            // Drag and Drop functionality
            function addDragAndDropListeners() {
                const maItems = document.querySelectorAll('.ma-item');
                maItems.forEach(item => {
                    item.draggable = true;
                    item.addEventListener('dragstart', handleDragStart);
                    item.addEventListener('dragover', handleDragOver);
                    item.addEventListener('drop', handleDrop);
                    item.addEventListener('dragend', handleDragEnd);
                });
            }



            function handleDragOver(e) {
                e.preventDefault();
                const draggingItem = document.querySelector('.dragging');
                if (!draggingItem) return;

                const list = e.currentTarget.parentNode;
                const afterElement = getDragAfterElement(list, e.clientY);

                if (afterElement) {
                    list.insertBefore(draggingItem, afterElement);
                } else {
                    list.appendChild(draggingItem);
                }
            }

            function updateMAOrder() {
                const maItems = document.querySelectorAll('.ma-item');
                maItems.forEach((item, index) => {
                    const ma = marketAreas.find(ma => ma.id === parseInt(item.dataset.id));
                    if (ma) {
                        ma.order = index;
                    }
                });
                
                // Sort the marketAreas array by the new order
                marketAreas.sort((a, b) => a.order - b.order);
                
                // Update the map to reflect the new order
                updateMap();
            }

            // Helper function to handle outside map visibility changes
            function handleMapVisibilityChange(maId = null, zoomToArea = true) {
                if (maId) {
                    // Handle single market area visibility change
                    const ma = marketAreas.find(ma => ma.id === maId);
                    if (ma) {
                        updateMap(maId, zoomToArea);
                    }
                } else {
                    // Handle all visible market areas
                    const visibleAreas = marketAreas.filter(ma => ma.visible);
                    if (visibleAreas.length > 0) {
                        updateMap(null, zoomToArea);
                    } else {
                        updateMap();
                    }
                }
            }

            function displaySearchResults(suggestions) {
                const searchResults = document.getElementById('searchResults');
                searchResults.innerHTML = '';

                if (suggestions.length === 0) {
                    searchResults.style.display = 'none';
                    return;
                }

                suggestions.forEach(suggestion => {
                    const div = document.createElement('div');
                    div.className = 'search-result-item';
                    div.style.padding = '8px 12px';
                    div.style.cursor = 'pointer';
                    div.style.borderBottom = '1px solid #eee';
                    div.style.transition = 'background-color 0.2s';
                    
                    div.textContent = suggestion.text;
                    div.dataset.magicKey = suggestion.magicKey;
                    
                    div.addEventListener('mouseover', () => {
                        div.style.backgroundColor = '#f0f0f0';
                    });
                    
                    div.addEventListener('mouseout', () => {
                        div.style.backgroundColor = 'white';
                    });
                    
                    div.onclick = () => selectSearchResult(suggestion);
                    searchResults.appendChild(div);
                });

                searchResults.style.display = 'block';
            }

            function selectSearchResult(suggestion) {
                const searchInput = document.getElementById('searchInput');
                searchInput.value = suggestion.text;
                document.getElementById('searchResults').style.display = 'none';

                require([
                    "esri/request",
                    "esri/geometry/Extent"
                ], function(esriRequest, Extent) {
                    const url = "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates";
                    const params = {
                        singleLine: suggestion.text,
                        magicKey: suggestion.magicKey,
                        f: "json",
                        outFields: "*",
                        outSR: "102100" // Web Mercator
                    };

                    esriRequest(url, {
                        query: params
                    }).then(function(response) {
                        if (response.data.candidates && response.data.candidates.length > 0) {
                            const result = response.data.candidates[0];
                            const extent = new Extent({
                                xmin: result.extent.xmin,
                                ymin: result.extent.ymin,
                                xmax: result.extent.xmax,
                                ymax: result.extent.ymax,
                                spatialReference: { wkid: 102100 }
                            });

                            // Determine zoom level based on result type
                            let zoomLevel;
                            if (result.attributes.Addr_type === 'POI') {
                                zoomLevel = 16;
                            } else if (result.attributes.Addr_type === 'StreetAddress') {
                                zoomLevel = 15;
                            } else if (result.attributes.Addr_type === 'Postal') {
                                zoomLevel = 13;
                            } else if (result.attributes.Type === 'City') {
                                zoomLevel = 11;
                            } else if (result.attributes.Type === 'County') {
                                zoomLevel = 9;
                            } else if (result.attributes.Type === 'State') {
                                zoomLevel = 6;
                            } else {
                                // Calculate zoom based on extent size
                                const extentSize = Math.max(
                                    extent.xmax - extent.xmin,
                                    extent.ymax - extent.ymin
                                );
                                zoomLevel = Math.round(19 - Math.log2(extentSize / 50));
                            }

                            // Zoom to location
                            if (mapViewInstance) {
                                mapViewInstance.goTo({
                                    target: extent,
                                    zoom: zoomLevel
                                }, {
                                    duration: 1000,
                                    easing: "ease-out"
                                }).catch((error) => {
                                    console.error("Error zooming to location:", error);
                                });
                            }
                        }
                    }).catch(function(error) {
                        console.error("Error finding location:", error);
                    });
                });
            }        
            // Updated debounce function to better handle errors
            
            // Add cleanup function for map events
            function cleanupMapEvents() {
                if (mapViewInstance && mapViewInstance.mapEventHandles) {
                    Object.values(mapViewInstance.mapEventHandles).forEach(handle => {
                        if (handle && typeof handle.remove === 'function') {
                            handle.remove();
                        }
                    });
                    mapViewInstance.mapEventHandles = null;
                }
            }
            // Add these state tracking variables
            let mapUpdateTimer = null;
            let lastMapUpdate = 0;
            const MAP_UPDATE_THROTTLE = 1000; // Minimum time between updates in ms
            let pendingMapUpdate = false;

            // Enhanced debounce with immediate option
            function debounce(func, wait, immediate = false) {
                let timeout;
                return function(...args) {
                    const context = this;
                    const later = function() {
                        timeout = null;
                        if (!immediate) func.apply(context, args);
                    };
                    const callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) func.apply(context, args);
                };
            }

            // Only track center changes without forcing map movement
            const handleMapCenterUpdate = debounce(async (newCenter) => {
                if (!mapViewInstance || !newCenter) return;
                
                const now = Date.now();
                if (now - lastMapUpdate < MAP_UPDATE_THROTTLE) {
                    return;
                }

                try {
                    const geographicCenter = await webMercatorToGeographic(newCenter);
                    if (geographicCenter) {
                        // Only log the center update without moving the map
                        console.log('Map center updated:', {
                            longitude: geographicCenter.longitude,
                            latitude: geographicCenter.latitude
                        });
                    }
                } catch (error) {
                    console.error('Error updating map center:', error);
                }
            }, 500);
                    
       
            function setupColorInputEventListeners() {
                const customColorPicker = document.getElementById('customColorPicker');
                const hexInput = document.getElementById('hexInput');
        
                if (customColorPicker && hexInput) {
                    customColorPicker.addEventListener('input', function() {
                        hexInput.value = this.value;
                    });
        
                    hexInput.addEventListener('input', function() {
                        if (/^#[0-9A-F]{6}$/i.test(this.value)) {
                            customColorPicker.value = this.value;
                        }
                    });
                }
            }
        
            function logWorksheetData(ws_data) {
                console.group('Worksheet Data Structure');
                console.log('Total rows:', ws_data.length);
                
                // Log header rows
                console.group('Header Rows (First 3 rows)');
                ws_data.slice(0, 3).forEach((row, i) => {
                    console.log(`Row ${i}:`, row);
                });
                console.groupEnd();

                // Log some sample data rows
                console.group('Sample Data Rows');
                ws_data.slice(4, 8).forEach((row, i) => {
                    console.log(`Row ${i + 4}:`, row);
                });
                console.groupEnd();

                // Log summary
                const columnCounts = ws_data.map(row => row.length);
                console.log('Column counts:', columnCounts);
                console.log('Max columns:', Math.max(...columnCounts));
                console.log('Min columns:', Math.min(...columnCounts));
                console.groupEnd();
            }

            function addToWorksheet(ws, data, rowIndex, colIndex, style = null) {
                const cellRef = XLSX.utils.encode_cell({ r: rowIndex, c: colIndex });
                ws[cellRef] = { v: data };
                if (style) {
                    ws[cellRef].s = style;
                }
                console.log(`Added cell ${cellRef}:`, { value: data, style: style });
            }
            
            // Helper formatting functions
            function formatCurrency(value) {
                return new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 0
                }).format(value);
            }

            function formatPercent(value) {
                return new Intl.NumberFormat('en-US', {
                    style: 'percent',
                    minimumFractionDigits: 1,
                    maximumFractionDigits: 1
                }).format(value / 100);
            }

            function formatNumber(value) {
                return new Intl.NumberFormat('en-US').format(value);
            }

            function loadColorPalettes() {
                const savedPalettes = localStorage.getItem('colorPalettes');
                if (savedPalettes) {
                    colorPalettes = JSON.parse(savedPalettes);
                }
                updateColorPaletteDisplay();
            }
        </script>
    <!-- Replace the existing export dialog HTML with this -->
    <div id="exportDialog" class="fixed inset-0 bg-black bg-opacity-50 hidden" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.5); display: none; z-index: 1000;">
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; width: 800px; max-height: 90vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="font-size: 1.25rem; font-weight: 600;">Export Data</h2>
                <button onclick="closeExportDialog()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer;">&times;</button>
            </div>
            
            <!-- Export Name Section -->
            <div style="margin-bottom: 20px;">
                <label for="exportName" style="display: block; margin-bottom: 5px; font-weight: 500;">Export Name</label>
                <input type="text" id="exportName" class="form-control" placeholder="Enter file name" style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
            </div>
            
            <!-- Market Areas Selection -->
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; margin-bottom: 10px;">
                    <input type="checkbox" id="selectAllMAs" class="acs-checkbox" checked>
                    <span class="acs-label" style="margin-left: 8px;">Select All Market Areas</span>
                </label>
                
                <div id="maCheckboxList" style="margin-bottom: 20px; border: 1px solid #eee; border-radius: 4px; padding: 10px; max-height: 150px; overflow-y: auto;">
                    <!-- Market Areas will be dynamically inserted here -->
                </div>
            </div>

            <div style="margin-bottom: 20px;">
                <h3 style="font-size: 1rem; font-weight: 600; margin-bottom: 10px;">Select Variables</h3>
                
                <!-- Unified Search Bar -->
                <div style="margin-bottom: 10px;">
                    <input type="text" id="variableSearch" class="form-control" placeholder="Search variables in both lists..." 
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px;">
                </div>
                
                <div style="display: flex; gap: 20px;">
                    <!-- Available Variables -->
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <label>Available Variables</label>
                            <label style="display: flex; align-items: center;">
                                <input type="checkbox" id="selectAllAvailable" class="acs-checkbox">
                                <span class="acs-label" style="margin-left: 4px;">Select All</span>
                            </label>
                        </div>
                        <div id="availableVariables" style="border: 1px solid #eee; border-radius: 4px; height: 200px; overflow-y: auto; padding: 10px;">
                            <!-- Available variables will be listed here -->
                        </div>
                    </div>
            
                    <!-- Transfer Buttons -->
                    <div style="display: flex; flex-direction: column; justify-content: center; gap: 10px;">
                        <button onclick="moveSelectedVariables('right')" class="button" style="padding: 8px;">→</button>
                        <button onclick="moveSelectedVariables('left')" class="button" style="padding: 8px;">←</button>
                    </div>
            
                    <!-- Selected Variables -->
                    <div style="flex: 1;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <label>Selected Variables</label>
                            <label style="display: flex; align-items: center;">
                                <input type="checkbox" id="selectAllSelected" class="acs-checkbox">
                                <span class="acs-label" style="margin-left: 4px;">Select All</span>
                            </label>
                        </div>
                        <div id="selectedVariables" style="border: 1px solid #eee; border-radius: 4px; height: 200px; overflow-y: auto; padding: 10px;">
                            <!-- Selected variables will be listed here -->
                        </div>
                    </div>
                </div>
            </div>
            
            
            <!-- Action Buttons -->
            <div style="display: flex; justify-content: flex-end; gap: 10px;">
                <button onclick="closeExportDialog()" class="button" style="padding: 8px 16px;">Cancel</button>
                <button onclick="executeExport()" class="button green-button" style="padding: 8px 16px;">Export</button>
            </div>
        </div>
    </div>
    </body>
</html>